<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UVA1347 Tour</title>
      <link href="/2019/12/07/UVA1347/"/>
      <url>/2019/12/07/UVA1347/</url>
      
        <content type="html"><![CDATA[<p>按x递增顺序给出n个点,设计一条从最左边的点出发到最右边的点再返回的路径,使得除了最左点与最右点之外每个点恰好经过一次,且路径总长度最短.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>假设两个人同时从最左点出发,则用 $d(i,j)$ 表示$1-max(i,j)$ 全部走过,且两个人分别处于 $i,j$ 时到终点还要多长距离.  </p><p>易知$d(i,j) = d(j,i)$ 则规定 $i &gt; j$ .因每个点都要走过,所以不能跳过任何点.则状态转移方程为</p><p>$d(i,j) = \min(d(i+1,j)+dist(i,i+1),d(i+1,i)+dist(j,i+1)$ 即 $i$ 走到 $i+1$ 或 $j$ 走到 $i+1$ .</p><p>最终答案为 $d(1,1)$ 或 $dist(1,2)+d(2,1)$,因为第一步必定是某人走到了 $2$ 点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; c=getchar(); <span class="keyword">if</span> (c==<span class="string">'-'</span>)f=<span class="number">-1</span>; &#125; <span class="keyword">while</span> (c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; ans=(ans &lt;&lt; <span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>; c=getchar(); &#125; <span class="keyword">while</span> (c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">return</span> f * ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dis[i][j];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="built_in">std</span>::<span class="built_in">abs</span>(nodes[i].x - nodes[j].x);</span><br><span class="line">        <span class="keyword">double</span> y = <span class="built_in">std</span>::<span class="built_in">abs</span>(nodes[i].y - nodes[j].y);</span><br><span class="line">        dis[i][j] = <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> f[i][j];</span><br><span class="line">    f[i][j] = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == n - <span class="number">1</span>)</span><br><span class="line">        f[i][j] = dist(n<span class="number">-1</span>,n) + dist(j,n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f[i][j] = <span class="built_in">std</span>::min(dist(i,i+<span class="number">1</span>)+d(i+<span class="number">1</span>,j),dist(j,i+<span class="number">1</span>)+d(i+<span class="number">1</span>,i));</span><br><span class="line">    <span class="keyword">return</span> f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1010</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1010</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    dis[i][j] = <span class="number">-1.0</span>;</span><br><span class="line">    f[i][j] = <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//上面的初值不写会WA</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nodes[i].x,&amp;nodes[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1;i &lt; n - 1;i ++)</span></span><br><span class="line"><span class="comment">          f[n-1][i] = dist(n-1,n) + dist(i,n);</span></span><br><span class="line"><span class="comment">        for(int i = n - 2;i &gt; 1;i --)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j = i - 1;j &gt; 0;j --)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                f[i][j] = std::min(dist(i,i+1)+f[i+1][j],dist(j,i+1)+f[i+1][i]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">       */</span> <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,d(<span class="number">1</span>,<span class="number">1</span>));<span class="comment">//dist(1,2)+f[2][1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码注释中为递推版</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1352 没有上司的舞会</title>
      <link href="/2019/12/06/P1352/"/>
      <url>/2019/12/06/P1352/</url>
      
        <content type="html"><![CDATA[<p>一棵树上儿子和父亲不能同时出现,求最大点权和  </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">P1352</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>树形DP经典题,不妨用  $ f[i][0]$  表示 $i$ 号不来时(下属来不来都可以)的最大快乐指数, $f[i][1]$ 表示 $i$ 号来时(下属一定都不来)的最大快乐指数</p><p>则</p><p> $f[x][0] = \Sigma({\max(f[v][0],f[v][1])}),v\in son[x]$  </p><p>$f[x][1] = \Sigma(f[v][0])+w[x] ,v \in son[x]$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">6005</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[<span class="number">6005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">6005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[r][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">f[r][<span class="number">1</span>] = w[r];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; son[r].size();i ++)</span><br><span class="line">&#123;</span><br><span class="line">dp(son[r][i]);</span><br><span class="line">f[r][<span class="number">0</span>] += <span class="built_in">std</span>::max(f[son[r][i]][<span class="number">0</span>],f[son[r][i]][<span class="number">1</span>]);</span><br><span class="line">f[r][<span class="number">1</span>] += f[son[r][i]][<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> f,s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;f);</span><br><span class="line">son[f].push_back(s);</span><br><span class="line">in[s] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!in[i])</span><br><span class="line">&#123;</span><br><span class="line">root = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">std</span>::max(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1462 通往奥格瑞玛的道路</title>
      <link href="/2019/12/05/P1462/"/>
      <url>/2019/12/05/P1462/</url>
      
        <content type="html"><![CDATA[<h2 id="简要思路"><a href="#简要思路" class="headerlink" title="简要思路"></a>简要思路</h2><p>二分答案+最短路验证  </p><p>点权为费用,所以只挑符合答案的点走,边权为血量,显然最短路是扣血最少的,所以可以用最短路  </p><p>这个题意毒瘤,其实是求路径上的边权的最大值最小为多少(于是就是二分</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,b;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,d;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; rhs)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">    <span class="keyword">return</span> f*ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;edge&gt; G[<span class="number">10000</span>+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> N[<span class="number">10000</span>+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">10000</span>+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge e;</span><br><span class="line">    e.v = v,e.w = w;</span><br><span class="line">    G[u].push_back(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;node&gt; Q;</span><br><span class="line">    node cur;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    cur.u = <span class="number">1</span>,cur.d = <span class="number">0</span>;</span><br><span class="line">    Q.push(cur);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cur = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(cur.d != dis[cur.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[cur.u].size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[cur.u]+G[cur.u][i].w &lt; dis[G[cur.u][i].v] &amp;&amp; N[G[cur.u][i].v] &lt;= M)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[G[cur.u][i].v] = dis[cur.u]+G[cur.u][i].w;</span><br><span class="line">                Q.push(&#123;G[cur.u][i].v,dis[G[cur.u][i].v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n] &lt; b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1462.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1462.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    n = read(),m = read(),b = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        N[i] = read();</span><br><span class="line">        mx = N[i] &gt; mx ? N[i] : mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(),v = read(),w = read();</span><br><span class="line">        <span class="keyword">if</span>(u != v)</span><br><span class="line">        &#123;</span><br><span class="line">            addEdge(u,v,w);</span><br><span class="line">            addEdge(v,u,w);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!dijkstra(<span class="number">0x3f3f3f3f</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"AFK"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = mx+<span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = dijkstra(mid);</span><br><span class="line">        <span class="keyword">if</span>(res)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2019游记</title>
      <link href="/2019/11/17/CSP2019%E6%B8%B8%E8%AE%B0/"/>
      <url>/2019/11/17/CSP2019%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>不知不觉中，就从无忧无虑的初中蒟蒻普及组选手经历了中考爆炸，变成了高一蒟蒻。</p><p>DAY0  </p><p>　　周五为了赶去试机请了一天假，两小时高铁从沈阳赶到大连。中午跟队友们打了两盘三国杀，试机过程中旁边大佬聊的算法什么的都听不懂。晚上五人组团订了金拱门乐享三人餐x2，五个男人吃六人餐。酒店环境还蛮好的，有冰箱（虽然没什么用）和浴缸。</p><p>​        晚上室友用我的笔记本调了1h+的kruskal，我泡个澡出来他发现自己链式前向星第一句写的g[cnt++].u = u。边错位了…</p><p>DAY1</p><p>　　早上酒店自助餐，我没什么可吃的于是搬空了迷你三明治。</p><p>　　8:25 听见监考还在研究怎么发题，顿感事情不妙。果然，发题出锅了，最后U盘传题，分片延时。我在的A区最早拿到题。</p><p>　　8:40 打开T1，格雷码。看了几分钟找到了规律。最后一位是0110，倒数第二位是00111100这样子的，然后从低位往高位枚举处理一下就好。但是慌得不行，怎么写怎么错。期间测试64的特判的时候还错把64 1当成了全0导致我以为自己程序输出最后一位是1出问题了。。。</p><p>　　于是我T1<strong>调了两小时</strong>，当场去世。</p><p>　　10:40 心凉的不行，迅速扫了一眼T2和T3，感觉T3链的分比较可做，然后就敲了50min左右，然而最后发现编号搞错了。我心灰意冷，犯下了另一个错误，放弃T3打开了T2。<strong>T3爆零</strong></p><p>　　11:30 开搞T3，想了线段树之类的不会写，然后一看时间不足了（并且当时还以为没有延时），打个n^3的暴力拿点部分分也好。<strong>然而没有拿到，T2又爆0了。</strong>　　 </p><p>​        DAY1结束，出来发现有个队友忘了删文件注释了，惨。</p><p>DAY1.5</p><p>​        因为选手程序发的很快，所以下午就用手机在oitiku上测了一下，T1貌似是A了，然后T2T3果不其然地爆零。一看群里大众分210，感觉两天也拿不到210。</p><p>​        吃完饭在酒店里打狼人杀，队友表面老实实则各个十分精明，只有我一个人彻头彻尾地被骗得很惨。</p><p>​        晚上三人订了汉堡王，套餐香得不行。一边吃一边看《飞驰人生》，到结局室友在旁边我眼泪也在悄悄往下流，也许哪里有些共鸣。</p><p>DAY2</p><p>　　赛前毒奶：昨天都考两棵树了今天不能再考了，我都没学过树别这么对我。</p><p>　　打开题面：还来？？？</p><p>　　T1都不会了，感觉像DP然而没推出式子，想写记忆化搜索也没写出来。于是果断改写爆搜，写到一半第n次按下ctrl+s的时候系统提示存储空间不足。</p><p>　　存储空间不足？！我就写点代码加起来不到5k还能把硬盘写满？？？尝试删掉一些没用的东西，还是存不下我的代码。没办法，只得呼叫监考，最近的监考小姐姐完全束手无策，于是叫来了监考小哥哥，还是没用，监考叔叔也来了XD。删东西，重启皆无用，最后只能拿着u盘准备转移，然而考场电脑一插u盘就死机，好不容易搞定了，到新座位上一插发现还没拷出来…小哥哥重跑一趟，终于得救，然而这时候我的手已经在疯狂发抖了。</p><p>　　颤抖着调完T1，再次跳过T2去写了T3的链。与昨天完全一致…又是链，结果我今天又写炸了。光荣爆零。</p><p>​        考试结束，爆零x4。</p><p>oitiku和洛谷:100+0+0+32+0+0 = 132  </p><p>赛前毒奶目标T1，结果真的只有T1有分，别的暴力都没写出来。</p><p>　　现在看来，自己明明有机会变强，从初二开始学OI，却在初中每日颓废，荒废了大把时光，现在去看学弟的博客什么的，也感到羡慕。可又有什么羡慕的呢?自己只是比他们环境稍差了些。</p><p>就算回到当时，没有一个教训将我打醒，也不会醒悟吧。</p><p>无论多么悔恨，也不会变强一分，只会离梦想越来越远。</p><p>既然如此，我还是去刷题吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtcoderBeginnerContest143题解</title>
      <link href="/2019/10/21/Atcoder-Beginner-Contest-143%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/10/21/Atcoder-Beginner-Contest-143%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_a" target="_blank" rel="noopener">Curtain</a></p><p>A-2B,小于0则取0  </p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_b" target="_blank" rel="noopener">TAKOYAKI FESTIVAL 2019</a></p><p>握手原理枚举每组takoyaki，累加其积。  </p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_c" target="_blank" rel="noopener">Slimes</a></p><p>连续相同字母的算一个</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_d" target="_blank" rel="noopener">Triangles</a></p><p>排序后枚举每种情况判断是否构成三角形（此时只需判断两小边之和大于大边）</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_e" target="_blank" rel="noopener">Travel by Car</a></p><p>首先跑一遍Floyd求出所有点间的最短路，从而将最少需要加k次油的路（即每两点）分成k+1个点建图，在新生成的图上再次Floyd求出最短路。  </p><p>之后对于每个询问给出输出。</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://atcoder.jp/contests/abc143/tasks/abc143_f" target="_blank" rel="noopener">Distinct Numbers</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数学习笔记</title>
      <link href="/2019/10/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量(vector)"></a>向量(vector)</h2><p>2019.10.4</p><h3 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h3><ul><li><p>几何表示：具有方向的线段叫做有向线段，向量为有向线段（在线性代数中，通常以原点为起点）</p><p>$ \vec u=\begin{bmatrix}2 \\3 \\\end{bmatrix} $ 表示为图中箭头</p><p><img src="https://i.loli.net/2019/10/05/i35OBYfJcpnDmqo.png" alt="vector.png"></p></li><li><p>坐标表示：有序的数字列表</p></li></ul><script type="math/tex; mode=display">\begin{bmatrix}a \\b \\\end{bmatrix}</script><p>​            如上二维向量代表由原点指向 (a,b) 的箭头，也就是从原点在x轴移动a“步”,再在y轴移动b“步”。多维同理  </p><h3 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h3><h4 id="向量加法-vector-addition"><a href="#向量加法-vector-addition" class="headerlink" title="向量加法(vector addition)"></a>向量加法(vector addition)</h4><ul><li><p>三角形法则  </p><p>将一个向量的起点移到另一个向量的终点，这两个向量的和为后者的起点指向前者的终点 ，多个向量同理 </p><p><img src="https://i.loli.net/2019/10/05/wE1y2hsCH6tdreI.png" alt="tri.png"></p><p>$ \vec u+\vec v=\vec w $</p></li></ul><p>所以</p><script type="math/tex; mode=display">\begin{bmatrix}a \\b \\\end{bmatrix}+\begin{bmatrix}c \\d \\\end{bmatrix}=\begin{bmatrix}a+c \\b+d \\\end{bmatrix}</script><p>相当于先在x轴移动 a+c “步”，再在y轴移动 b+d “步”，效果等同于在x轴移动 a “步”，在y轴移动 b “步”，再在x轴移动 c “步”，在y轴移动 d “步”。</p><h4 id="向量数乘-vector-multiplication-by-a-number"><a href="#向量数乘-vector-multiplication-by-a-number" class="headerlink" title="向量数乘(vector multiplication by a number)"></a>向量数乘(vector multiplication by a number)</h4><p>对向量的<strong>缩放</strong>,用于控制缩放的量称为<strong>标量(scalar)</strong>，在这里通常可与<strong>数字(number)</strong>互相替换。</p><p><img src="https://i.loli.net/2019/10/05/W4dbrEGceth3jQN.png" alt="vectormult.png"></p><script type="math/tex; mode=display">x\cdot\begin{bmatrix}a \\b \\\end{bmatrix} =\begin{bmatrix}xa \\xb\end{bmatrix}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2019/09/24/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2019/09/24/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>一种查询和修改复杂度都为 $\log(n)$ 的数据结构。可以通过前缀和的方式查询任意两个位置间所有元素和，即区间查询。朴素的树状数组支持单点修改。经简单修改借助差分可区间修改，单点查询。再多加辅助数组可实现区间修改，区间查询。  </p><p>与线段树相似，相比之下线段树适用范围更广，而树状数组效率更高，代码更短。不过树状数组并不是真正的树形结构，而是树形结构思想的“数组”。    </p><p>先码着</p><p>单点修改+区间查询</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> C[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span><span class="comment">//A[i]+=k,A为原数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] += k;</span><br><span class="line">        i += lb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += C[i];</span><br><span class="line">        i -= lb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        add(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t,a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = sum(b) - sum(a<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间修改+单点查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> C[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i&amp;-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] += k;</span><br><span class="line">        i += lb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qeury</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += C[i];</span><br><span class="line">        i -= lb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> now,last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;now);</span><br><span class="line">        add(i,now-last);</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t,a,b,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;k);</span><br><span class="line">            add(a,k);</span><br><span class="line">            add(b+<span class="number">1</span>,-k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = qeury(a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中每周刷题记录</title>
      <link href="/2019/09/08/%E9%AB%98%E4%B8%AD%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/09/08/%E9%AB%98%E4%B8%AD%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><h2 id="11-24-12-1"><a href="#11-24-12-1" class="headerlink" title="11.24-12.1"></a>11.24-12.1</h2><p><a href="https://www.luogu.org/problem/P1198" target="_blank" rel="noopener">P1198[JSOI2008]最大数</a> 线段树  </p><p><a href="https://www.luogu.org/problem/P1341" target="_blank" rel="noopener">P1341无序字母对</a> 欧拉路</p><p><a href="https://www.luogu.org/problem/P2023" target="_blank" rel="noopener">P2023[AHOI2009]维护序列</a> 线段树</p><h3 id="11-18-11-24"><a href="#11-18-11-24" class="headerlink" title="11.18-11.24"></a>11.18-11.24</h3><p><a href="https://www.luogu.org/problem/P3373" target="_blank" rel="noopener">P3373[模板]线段树2</a>双 lazytag 的线段树  </p><p><a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">P3372[模板]线段树1</a>普通的线段树  </p><p><a href="https://www.luogu.org/problem/P1972" target="_blank" rel="noopener">P1972[SDOI2009]HH的项链</a> 树状数组  </p><p><a href="https://www.luogu.org/problem/P1120" target="_blank" rel="noopener">P1120小木棍[数据加强版]</a>  这个数据加强版卡掉了我DFS初值错误的程序(LOJ和UVA上的数据都没卡掉)  </p><p><a href="https://www.luogu.org/problem/UVA307" target="_blank" rel="noopener">UVA307小木棍Sticks</a> 搜索</p><p><a href="https://www.luogu.org/problem/P2024" target="_blank" rel="noopener">P2024[NOI2001]食物链</a> 带偏移量的并查集</p><p><a href="https://www.luogu.org/problem/P2330" target="_blank" rel="noopener">P2330[SCOI2005]繁忙的都市</a> 最小生成树  </p><p><a href="https://www.luogu.org/problem/P1546" target="_blank" rel="noopener">P1546最短网络 Agri-Net</a>  最小生成树  </p><p><a href="https://www.luogu.org/problem/P1441" target="_blank" rel="noopener">P1441砝码称重</a>  DFS</p><h3 id="11-11-11-17"><a href="#11-11-11-17" class="headerlink" title="11.11-11.17"></a>11.11-11.17</h3><p><a href="https://www.luogu.org/problem/P1462" target="_blank" rel="noopener">P1462通往奥格瑞玛的道路</a>二分答案+最短路  </p><p><a href="https://www.luogu.org/problem/P5650" target="_blank" rel="noopener">P5650基础字符串练习题</a> 这题我交了11次… </p><p><a href="https://www.luogu.org/problem/P1144" target="_blank" rel="noopener">P1144最短路计数</a>  最短路(由于本题特殊性也可以bfs)</p><p>CSP2019</p><p><a href="https://www.luogu.org/problem/P5657" target="_blank" rel="noopener">D1T1格雷码</a>  模拟?(结论题)</p><p><a href="https://www.luogu.org/problem/P5660" target="_blank" rel="noopener">J-T1数字游戏</a>  入门题</p><h3 id="11-04-11-10"><a href="#11-04-11-10" class="headerlink" title="11.04-11.10"></a>11.04-11.10</h3><p>51nod猴猴吃苹果   </p><p><a href="https://www.luogu.org/problem/P1091" target="_blank" rel="noopener">洛谷P1091合唱队形</a> 正反两次LIS  </p><p><a href="https://www.luogu.org/problem/P1060" target="_blank" rel="noopener">洛谷P1060开心的金明</a> 01背包  </p><p><a href="https://www.luogu.org/problem/P1010" target="_blank" rel="noopener">洛谷P1010幂次方</a>  递归  </p><p><a href="https://www.luogu.org/problem/P1088" target="_blank" rel="noopener">洛谷P1088火星人</a>  下一个排列(next_permutation)  </p><p><a href="https://www.luogu.org/problem/P1098" target="_blank" rel="noopener">洛谷P1098字符串的展开</a>  模拟  </p><p><a href="https://www.luogu.org/problem/P1603" target="_blank" rel="noopener">洛谷P1603斯诺登的密码</a>  字符串  </p><h3 id="10-28-11-03"><a href="#10-28-11-03" class="headerlink" title="10.28-11.03"></a>10.28-11.03</h3><p><a href="https://www.luogu.org/problem/P1038" target="_blank" rel="noopener">洛谷P1038神经网络</a>  拓扑排序  </p><h3 id="10-21-10-27"><a href="#10-21-10-27" class="headerlink" title="10.21-10.27"></a>10.21-10.27</h3><p><a href="https://www.luogu.org/problem/P2661" target="_blank" rel="noopener">洛谷P2661信息传递</a>  DFS 最小环  </p><p><a href="https://www.luogu.org/problem/P1032" target="_blank" rel="noopener">洛谷P1032字串变换</a>  BFS 字符串  </p><h3 id="10-14-10-20"><a href="#10-14-10-20" class="headerlink" title="10.14-10.20"></a>10.14-10.20</h3><p>两天做了三场比赛里的签到题…</p><p>CF594Div.2两道水题</p><p><a href="https://atcoder.jp/contests/abc143" target="_blank" rel="noopener">AtCoderBeginnerContest143</a>ABCD四道水题</p><p><a href="https://www.luogu.org/problem/P5595" target="_blank" rel="noopener">XR-4歌唱比赛</a>另一道大水模拟题</p><p><a href="https://www.luogu.org/problem/P5594" target="_blank" rel="noopener">XR-4模拟赛</a>水模拟题</p><h3 id="10-7-10-13"><a href="#10-7-10-13" class="headerlink" title="10.7-10.13"></a>10.7-10.13</h3><p>这周不见了orz</p><p>大概是因为月考</p><h3 id="9-30-10-6"><a href="#9-30-10-6" class="headerlink" title="9.30-10.6"></a>9.30-10.6</h3><p><a href="https://www.luogu.org/problem/P1030" target="_blank" rel="noopener">洛谷P1087FBI树</a></p><p><a href="https://www.luogu.org/problem/P1030" target="_blank" rel="noopener">洛谷P1030求先序序列</a></p><h3 id="9-23-9-29"><a href="#9-23-9-29" class="headerlink" title="9.23-9.29"></a>9.23-9.29</h3><p><a href="https://www.luogu.org/problem/P2058" target="_blank" rel="noopener">洛谷P2058统计和</a>  树状数组单点修改+区间查询  </p><p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">洛谷P1908逆序对</a>  树状数组求逆序对</p><p><a href="https://www.luogu.org/problem/P3374" target="_blank" rel="noopener">洛谷P3374[模板]树状数组1</a>  树状数组单点修改+区间查询</p><p><a href="https://www.luogu.org/problem/P3368" target="_blank" rel="noopener">洛谷P3368[模板]树状数组2</a>  树状数组区间修改+单点查询  </p><h3 id="9-16-9-22"><a href="#9-16-9-22" class="headerlink" title="9.16-9.22"></a>9.16-9.22</h3><p><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">洛谷P1082同余方程</a>  </p><h3 id="9-9-9-15"><a href="#9-9-9-15" class="headerlink" title="9.9-9.15"></a>9.9-9.15</h3><p><a href="https://www.luogu.org/problem/P1478" target="_blank" rel="noopener">洛谷P1478陶陶摘苹果（升级版</a> 排序 模拟    </p><p><a href="https://www.luogu.org/problem/P1339" target="_blank" rel="noopener">洛谷P1339[USACO09OCT]热浪Heat Wave</a> 最短路  </p><p><a href="https://www.luogu.org/problem/P1196" target="_blank" rel="noopener">洛谷P1196[NOI2002]银河英雄传说</a> 带权并查集  </p><p><a href="https://www.luogu.org/problem/P1111" target="_blank" rel="noopener">洛谷P1111修复公路</a> 并查集  </p><p><a href="https://www.luogu.org/problem/P1090" target="_blank" rel="noopener">洛谷P1090合并果子</a>  优先队列(小根堆)  </p><h3 id="9-2-9-8"><a href="#9-2-9-8" class="headerlink" title="9.2-9.8"></a>9.2-9.8</h3><p><a href="https://www.luogu.org/problem/P1226" target="_blank" rel="noopener">洛谷P1226【模板】快速幂||取余运算</a><br><a href="https://www.luogu.org/problem/P1160" target="_blank" rel="noopener">洛谷P1160队列安排</a> 双向链表<br><a href="https://www.luogu.org/problem/P1006" target="_blank" rel="noopener">洛谷P1006传纸条</a> 四维DP  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈算法之Dijkstra</title>
      <link href="/2018/12/30/Dijkstra/"/>
      <url>/2018/12/30/Dijkstra/</url>
      
        <content type="html"><![CDATA[<p>Dijkstra算法是典型的<strong>单源最短路径</strong>算法，也就是用于计算一个节点到其他节点的最短路径的算法。它的主要特点为以起始点中心，层层扩展。利用贪心的思想不断更新最短路。  </p><h2 id="算法主要思路"><a href="#算法主要思路" class="headerlink" title="算法主要思路"></a>算法主要思路</h2><p>取起点$s$，引入集合$S$和$U$，$S$中为已求出最短路径的节点（最短路径已确定），$U$中为未求出最短路径的节点。记节点$v$到$s$的距离为$dis[v]$  </p><p>易知初始时$S$中只有一个元素$s$，$dis[s]=0$，其余节点均在$U$中，$U$中与$s$相邻的节点到$s$的距离为边权，与$s$不相邻的节点到s的距离未知，视为$+\infty$。  </p><p>此时从$U$中找到$dis[k]$最小的节点$k$，显然$k$的最短路径已求出，则将$k$从$U$中移到$S$中。  </p><p>于是可以用$k$更新$U$中节点距离，由于与$k$相邻且不与$s$相邻的其它节点距离均为$+\infty$，故能更新。(实际实现中，称为松弛)</p><p>重复以上步骤，直至$U$为空集。  </p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://i.loli.net/2019/10/13/htoBjFzKGVnyw6D.png" alt="dij.png"></p><p>（该图为LuoguP4779样例图示，graphviz制作）</p><p>工作量稍大先坑着了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>松弛，严格来讲并不属于最短路算法，却是该算法的核心部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[u]+G[u][i].w &lt; dis[v])</span><br><span class="line">    dis[v] = dis[u]+G[u][i].w<span class="comment">//G[u][i]是一条从u指向v的边</span></span><br></pre></td></tr></table></figure><p>堆优化代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> m,n,s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line"></span><br><span class="line">&#125;;<span class="built_in">vector</span>&lt;edge&gt; G[MAXM];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d&gt;rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    edge newe;</span><br><span class="line">    newe.u = u,newe.v = v,newe.w = w;</span><br><span class="line">    G[u].push_back(newe);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        dis[i] = <span class="number">1000000000</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; Q;</span><br><span class="line">    Q.push((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node nown = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> &amp;u = nown.u,&amp;d = nown.d;</span><br><span class="line">        <span class="keyword">if</span>(d != dis[u])<span class="comment">//证明在此节点被取出之前u的最短路已被更新，则跳过这个节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[u].size();i ++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> &amp;w = G[u][i].w,&amp;v = G[u][i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+G[u][i].w &lt; dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u]+w;</span><br><span class="line">                Q.push((node)&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        addEdge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈算法之Kruskal</title>
      <link href="/2018/12/15/Kruskal/"/>
      <url>/2018/12/15/Kruskal/</url>
      
        <content type="html"><![CDATA[<p>mathjax: true</p><p>Kruskal是一种被广泛使用的最小生成树算法，其实质为一种贪心算法。相比Prim来说，比较好写，用的人也比较多。<br>首先我们需要知道最小生成树是个什么东西。</p><p>最小生成树<br>严格定义可以自己百度，通俗来讲就是连通所有节点的总权值最小的树，或者说所有边权和最小的生成树，所以“最小生成树”应是“最小权重生成树”的简称。<br>显然，非连通图中是没有最小生成树的。</p><p>算法过程<br>将边按边权从小到大排序，从权值最小的边开始，依次将边加入，如果某条边所连接的两个点已经连通，也就是加入该边后会形成环，则跳过这条边，直至加入(结点数-1)条边。</p><p>算法证明<br>首先感性理解下，在两个点已经连通的情况下，再加入连接这两条边的点的唯一作用就是凭空增加边权，所以不需要加该边。</p><blockquote><p>证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。</p><p>基础：对于算法刚开始时，显然成立（最小生成树存在）。</p><p>归纳：假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。</p><p>如果 $e$ 属于 $T$，那么成立。</p><p>否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$（一定只有一条）。</p><p>首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。</p><p>然后，$f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。</p><p>所以，$T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。</p></blockquote><p>引用内容摘自OI-wiki</p><p>算法具体实现<br>根据上述过程，我们可以知道，需要的操作有判断两个点是否连通，朴素做法为O(n^2)的BFS，显然过慢。而且还需要连边，于是我们就想到了一个数据结构：并查集<br>通过并查集，就可以做到查询两个点是否在同一棵树中和连接两棵树这些操作了。 </p><ol><li>读入后，对边按边权从小到大进行排序，下面代码中用的是结构体快排。 </li><li>遍历排序后存边的数组，如果目前考虑的边的两个结点已经连通（处于同一个集合里），则跳过这条边考虑下一条。否则将这条边加入已选边中（即为将这条边的两个结点所在集合合并）。 </li><li>当选择（结点数-1）条边时结束，此时已选边集合内为一颗最小生成树。 </li><li>如果有空我会补图（我会持续咕咕咕的。</li></ol><p>代码<br>(直接把我LuoguP3366的AC代码拿过来了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;<span class="comment">//u,v是两个点，w是边权</span></span><br><span class="line">&#125;;edge E[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpe</span><span class="params">(edge a,edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,tot;</span><br><span class="line"><span class="keyword">int</span> uset[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        uset[i] = i;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uset[x] != x)</span><br><span class="line">        uset[x] = find(uset[x]);</span><br><span class="line">    <span class="keyword">return</span> uset[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x),y = find(y);</span><br><span class="line">    uset[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; m)</span><br><span class="line">    &#123;   </span><br><span class="line">        tot = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(find(E[i].u) == find(E[i].v))</span><br><span class="line">    &#123;</span><br><span class="line">        kruskal(i+<span class="number">1</span>,num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        unionSet(E[i].u,E[i].v);</span><br><span class="line">        tot += E[i].w;</span><br><span class="line">        kruskal(i+<span class="number">1</span>,num+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    makeSet(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;E[i].u,&amp;E[i].v,&amp;E[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E+<span class="number">1</span>,E+m+<span class="number">1</span>,cmpe);</span><br><span class="line">    kruskal(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(tot == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"orz"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> Kruskal </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity学习心得</title>
      <link href="/2018/10/29/Unity%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
      <url>/2018/10/29/Unity%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>近些天总算下定决心开始学习Unity，所以开篇博客来督促自己，记录每天的成果。<br><a href="https://dynalist.io/d/xddnSO6WHWpqSFV0Yau20K-R" target="_blank" rel="noopener">Unity学习笔记</a>  </p><h3 id="2018-10"><a href="#2018-10" class="headerlink" title="2018.10"></a>2018.10</h3><h4 id="28-amp-29"><a href="#28-amp-29" class="headerlink" title="28&amp;29"></a>28&amp;29</h4><p>开始学习Unity，没找到什么入门资料，只能去官方网站看教程了。没想到教程质量还算可以，只不过大部分都是英文版，这时候才发现学英语是真的有用（逃。<br>开始按照<a href="https://unity3d.com/cn/learn/tutorials/s/roll-ball-tutorial" target="_blank" rel="noopener">roll a ball教程</a>学习。29日晚先看完了第一个视频，过几天也不一定再有这么多时间了，不知道多久才能把这个做完。总之，加油吧！  </p><h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><p>本来考虑买Unity3D和C#的书，后来上网看了一眼，实在没有什么有用的，不如硬啃官方文档。<br>跟着教程写了个控制球移动的小脚本，虽然大部分是一知半解，但总算是写出来了。<br>顺带着学了点C#的基础语法，浅显地理解了一点面向对象  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> speed; <span class="comment">//通过将每帧移动的距离乘speed，可以控制移动速度，</span></span><br><span class="line">                        <span class="comment">//定义成public即可在Unity中修改其值</span></span><br><span class="line">    <span class="keyword">private</span> Rigidbody rb;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)<span class="comment">//脚本运行的第一帧会调用（通常是游戏运行的第一帧</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody&gt;(); <span class="comment">//引用一个刚体组件，从而对这个刚体进行操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span> (<span class="params"></span>)<span class="comment">//有关物理计算时会调用</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">float</span> moveHorizontal = Input.GetAxis(<span class="string">"Horizontal"</span>);<span class="comment">//横轴移动的距离</span></span><br><span class="line">        <span class="keyword">float</span> moveVertical = Input.GetAxis(<span class="string">"Vertical"</span>);<span class="comment">//纵轴移动的距离</span></span><br><span class="line">        Vector3 movement = <span class="keyword">new</span> Vector3(moveHorizontal, <span class="number">0.0f</span>, moveVertical);<span class="comment">//三维向量</span></span><br><span class="line">        rb.AddForce(movement * speed);<span class="comment">//此处省略了第二个变量，力的作用方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于开始没有理解其工作方式，所以我弄了两个球体并都使用了这个脚本，结果是两个球都可以响应键盘的操作。</span></span><br><span class="line"><span class="comment">//所以这个GetComponent引用这个脚本“所在”的GameObject的某个Component</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018游记</title>
      <link href="/2018/10/13/NOIP2018%E6%B8%B8%E8%AE%B0/"/>
      <url>/2018/10/13/NOIP2018%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><p>第一次参加NOIP，所以把初赛也写进来了。<br>身为一个辽宁普及组选手，我没有zj大佬们的压力。赛前教练还半开玩笑地说着一分钟做完选择题然后看看读程序写结果就可以出来了（雾。然而我想着好歹也是第一次参加，还是待到结束比较好。于是我就蹭到了比赛结束（逃。同校的OIer简直有毒，我校都报的C++，结果他说他没练过C++，想报C，然后三十多分钟直接走了？？？<br>个人感觉题并不是很难（然后我就GG了将近三十分，最后那个双向链表没看明白，我太鶸了。<br>复赛见咯！<br>辽宁说普及组不卡初赛，应该不会挂吧。（小声bb</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><h3 id="初赛结束后"><a href="#初赛结束后" class="headerlink" title="初赛结束后"></a>初赛结束后</h3><p>初赛结束后就是月考了，由于本校OI地位为0，所以完全没有时间搞OI（这时候我就想到复赛大概是凉凉了</p><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>周六早晨坐高铁到了大连，由于时间比较紧，在火车站的肯德基简单吃了份早餐。<br>高铁路程两个小时左右也没睡着，九点多下了高铁，出站的时候还看到了隔壁班的OIer，然后坐了一个多小时的出租车最终到了大连大学。<br>下午两点左右开始试机，打了个快排模板发现调不出来，心里慌得一批…出来看了一眼快排  </p><p>密码竟然充满了政治气息，看到的时候一脸懵<br>看题的时候瞄了一眼机器配置，惊奇地发现CCF居然不是老爷机了？！  </p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>（比去年难多了，看到的时候还是有点慌，因为我忘了C++字符串的各种函数了…<br>开始的时候想了一会多个换行符的问题，结果看到只有一行，不愧是第一题。最后用了getchar解决了    </p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>题面挺有意思，我用的龙虎两方气势差，因为long long而重构了一遍<br>然而最后好像不知道怎么就写挂了，luogu测80分  </p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>看到题的时候想到是dp，但是我瞬间就明白了这不是我能a的题，然后开始写贪心…<br>结果贪心调炸了，去写了一下T4(一会再说<br>最后只拿了m=1的数据(凉凉</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>写这题的时候心态已经爆炸了， <a href="https://www.luogu.org/paste/1pirxx2h" target="_blank" rel="noopener">于是写了这么个东西</a><br><del>不知道能</del>不能骗到分  </p><p>估分100+80+10+ 0？ = 190<br>估计没有省一了吧，估计是最菜的初三OIer了…<br>然而有什么办法呢，退役是不可能退役的，只能接着肝了  </p><p>————2018.11.14</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2018/08/11/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2018/08/11/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的<strong>合并</strong>及<strong>查询</strong>问题。<br>它支持两种操作：</p><ul><li>查找 （Find）：确定某个元素处于哪个子集  </li><li>合并 (Union)：将两个子集合合并成同一个集合  <h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;<span class="comment">//i就在它本身的集合里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>举个例子<br>几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为“祖先”）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。<br>在这样的思想下，并查集的查找诞生了。我们可以用代码模拟这个过程。（路径压缩等会再说）  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN]; <span class="comment">//记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//寻找x的祖先</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="comment">//如果x是祖先则返回</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> find(fa[x]); <span class="comment">//如果不是则x的爸爸问x的爷爷</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这样最终会返回x的祖先。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>这样的确可以达成目的，但是显然效率实在太低。为什么呢？因为我们使用了太多没用的信息，我关心的是我祖先是谁，我爸爸是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。<strong>把在路径上的每个节点都直接连接到根上</strong>，这就是路径压缩。<br>于是用代码实现它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != fa[x])<span class="comment">//x不是自身的父亲，即x不是该集合的代表</span></span><br><span class="line">    fa[x] = find(fa[x]);<span class="comment">//查找x的祖先直到找到代表,于是顺手路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>宴会上，一个家族的祖先突然对另一个家族说:我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。<br>我们之前说过，并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//x与y所在家族合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y)<span class="comment">//原本就在一个家族里就不管了</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    fa[x] = y;<span class="comment">//把x的祖先变成y的祖先的儿子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启发式合并（选学）"><a href="#启发式合并（选学）" class="headerlink" title="启发式合并（选学）"></a>启发式合并（选学）</h3><p>一个祖先突然抖了机灵：“你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。”<br>启发式合并是将深度小的集合合并到深度大的集合（也成为按秩合并），但是笔者认为这样做的话路径压缩之后它就失去意义了，或按照节点数量，这样还可以减少下次路径压缩的工作量。（反正启发式合并用得很少，路径压缩已经够快了。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size[N];<span class="comment">//记录子树的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = find(x),yy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(xx == yy)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(size[xx] &gt; size[yy])<span class="comment">//保证小的合到大的里</span></span><br><span class="line">        swap(xx,yy);</span><br><span class="line">    fa[xx] = yy;</span><br><span class="line">    size[yy] += size[xx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度及空间复杂度"><a href="#时间复杂度及空间复杂度" class="headerlink" title="时间复杂度及空间复杂度"></a>时间复杂度及空间复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $ O(α(n)) $ ，其中α为反阿克曼函数，其增长极其缓慢，也就是说其平均运行时间可以认为是一个很小的常数。感兴趣的同学可以自行百科。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>显然为 $ O(n) $</p><h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><p>最小生成树 Kruskal算法的优化</p><p>本文作者为<a href="http://juicymio.github.io" target="_blank" rel="noopener">JuicyMio</a>，同时发表在<a href="https://oi-wiki.cf/data-structure/novice/dsu/" target="_blank" rel="noopener">OIwiki</a></p><p>除特别注明外，项目中除了代码部分均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="noopener">(Creative Commons BY-SA 4.0) 知识共享署名-相同方式共享 4.0 国际许可协议</a> 及附加的 <a href="https://github.com/zTrix/sata-license" target="_blank" rel="noopener">The Star And Thank Author License</a> 进行许可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU2049神、上帝以及老天爷题解及错排问题</title>
      <link href="/2018/07/24/HDU2049%E7%A5%9E%E3%80%81%E4%B8%8A%E5%B8%9D%E4%BB%A5%E5%8F%8A%E8%80%81%E5%A4%A9%E7%88%B7%E9%A2%98%E8%A7%A3%E5%8F%8A%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/24/HDU2049%E7%A5%9E%E3%80%81%E4%B8%8A%E5%B8%9D%E4%BB%A5%E5%8F%8A%E8%80%81%E5%A4%A9%E7%88%B7%E9%A2%98%E8%A7%A3%E5%8F%8A%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>mathjax: true</p><p>做到这道题的时候没有搜到讲得比较好的题解(主要原因是这题太简单,而我太弱不会写</p><p>我正在写的这篇讲得也不好(逃,而且这道题所考察的错排问题也是我的盲点,于是赶紧上网搜索了一下,做完了题,简略地写个题解复习一下</p><p>言归正传,想要做这道题,要先了解”错排问题”</p><p>问题: 十本不同的书放在书架上。现重新摆放，使每本书都不在原来放的位置。有几种摆法?</p><p>这个问题推广一下，就是<strong>错排问题</strong>，是组合数学中的问题之一。考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。</p><p>错排问题最早被尼古拉·伯努利和欧拉研究，因此历史上也称为伯努利-欧拉的装错信封的问题。这个问题有许多具体的版本，如在写信时将n封信装到n个不同的信封里，有多少种全部装错信封的情况?又比如四人各写一张贺年卡互相赠送，有多少种赠送方法?自己写的贺年卡不能送给自己，所以也是典型的错排问题。</p><p>以上摘自百度百科</p><p>然后这个问题怎么解呢?其实百度百科上已经有详细的证明了(<del>但是我没学会</del>,所以就讲一下递推式的推导,对于这道题来说已经完全够用了。<br>(以下参考自百度百科)</p><p><strong>显然</strong>，D(1) = 0(因为根本没法错）,D(2) = 1。所以可以开始考虑n大于等于3的情况。那么我们设第n个元素放在了第k位(哪个元素都无所谓,就有两种情况</p><ul><li><p>第k个元素放在第n位,也就是k,n互换,即他们两个已经完成错排了，那么<strong>又显然</strong>,问题与这两个元素无关了,变成了剩下的n-2个元素错排,也就是D(n-2)</p></li><li><p>第k个元素没放在第n位,<strong>再显然</strong>问题就变成了包括第k个元素在内的剩下(n-1)个元素的错排。即为D(n-1)</p></li></ul><p>除第n个元素外每个元素都有D(n-1)+d(n-2)种放法，所以总放法</p><p><strong>D(n) = n-1*(D(n-1)+D(n-2))</strong></p><p>错排问题还有通项公式，大家可以自行学习<del>我说过我不会</del></p><p>掌握了这个，本题就很简单了<del>本来就很简单</del>，只需要算出错排数D(n)和总排列n!,再除一下弄成百分数就好了</p><p>（有一个小坑，<del>正常人都能看出来</del>，会爆int</p><p>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> j[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//没办法错</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//只有互换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= <span class="number">20</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = (i<span class="number">-1</span>)*(d[i<span class="number">-1</span>]+d[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    j[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;i ++)</span><br><span class="line">    j[i] = j[i<span class="number">-1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="keyword">double</span>(d[t])*<span class="number">100</span>/<span class="keyword">double</span>(j[t]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2f%\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>转载易懂的博客</title>
      <link href="/2018/07/24/%E8%BD%AC%E8%BD%BD%E6%98%93%E6%87%82%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/24/%E8%BD%AC%E8%BD%BD%E6%98%93%E6%87%82%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集~</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP1157心得</title>
      <link href="/2018/07/24/LuoguP1157%E5%BF%83%E5%BE%97/"/>
      <url>/2018/07/24/LuoguP1157%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>只是一道dfs题，我做了半个小时左右。各种玄学错误，还有一些小细节处理不好，最后看到了一个题解指点迷津</p><p><a href="https://daybreak-frontline.blog.luogu.org/solution-p1157" target="_blank" rel="noopener">大佬的题解</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mian main</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> used[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(cnt == r+<span class="number">1</span>)<span class="comment">//非常有趣的做法，值得学习（是我太弱orz,为了避免负数的下标而把a[0]作为了一个起点，一个初始值而不是答案的一部分。只要多选一个数，然后在输出的时候直接无视掉a[0]就可以了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; cnt;i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a[cnt<span class="number">-1</span>];i &lt;= n;i ++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(!used[i])</span><br><span class="line">        &#123;</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        a[cnt] = i;</span><br><span class="line">        dfs(cnt+<span class="number">1</span>);</span><br><span class="line">        a[cnt] = <span class="number">0</span>;</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP1926【小书童--刷题大军】题解</title>
      <link href="/2018/07/24/LuoguP1926%E3%80%90%E5%B0%8F%E4%B9%A6%E7%AB%A5-%E5%88%B7%E9%A2%98%E5%A4%A7%E5%86%9B%E3%80%91%E9%A2%98%E8%A7%A3/"/>
      <url>/2018/07/24/LuoguP1926%E3%80%90%E5%B0%8F%E4%B9%A6%E7%AB%A5-%E5%88%B7%E9%A2%98%E5%A4%A7%E5%86%9B%E3%80%91%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>第一次发题解</strong></p><p>这题本蒟蒻纠结了好久,第一眼看上去像个01背包,但是我弱,我不会背包啊!于是我瞄了一眼数据范围,小的可怕2333,怪不得是橙题(那我还做那么久</p><p>暴搜显然能过,于是我调了一个小时的暴搜…</p><p>这两个东西怎么搜?把最短做完作业的时间搜出来再搜剩下时间能做多少题目？好像有点复杂了，后来分析一下，发现作业跟题目没有什么本质上的区别，只不过一个可以加题数，一个可以加分数。而本题要的又是保证分数的情况下要最大题数（这可不太好，有点本末倒置吧2333</p><p>所以可以把它们放在一起搜，就好写多了(主观认为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mian main</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k,r;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>,max = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> t,<span class="keyword">int</span> g)</span><span class="comment">//step通常用于控制当前要选择的元素 t时间 g分数</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(step &lt; n+m)<span class="comment">//只要选择没有做完（确定每个元素选或不选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t-a[step][<span class="number">0</span>] &gt;= <span class="number">0</span>)  <span class="comment">//如果选了还没超时</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(step &lt; n)<span class="comment">//如果选到的是题（因为题存在a[0]~a[n-1],则刷题数+1</span></span><br><span class="line">            tot ++;                                         </span><br><span class="line">            dfs(step+<span class="number">1</span>,t-a[step][<span class="number">0</span>],g+a[step][<span class="number">1</span>]);<span class="comment">//选</span></span><br><span class="line">            <span class="keyword">if</span>(step &lt; n)<span class="comment">//如果之前加过了，还要在出口减回来</span></span><br><span class="line">            tot --;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(step+<span class="number">1</span>,t,g);<span class="comment">//当然可以不做这道题/作业</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g&gt;=k &amp;&amp; t&gt;=<span class="number">0</span>)<span class="comment">//及格并且没有超时</span></span><br><span class="line">            max = <span class="built_in">std</span>::max(max,tot);</span><br><span class="line">        <span class="comment">//tot = 0;这个地方为什么不能清0，因为回溯还要用到</span></span><br><span class="line">                <span class="comment">//而且之前选了之后递归的出口已经减回去了（这个地方我调了好久</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n+m; i++)<span class="comment">//放在一起存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &lt; n+m;i ++)<span class="comment">//从n往后就是有分数的作业</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,r,<span class="number">0</span>);<span class="comment">//数组是从0从开始存放的，所以step也从0开始（个人习惯而已</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//拒绝抄袭，从我做起</span></span><br><span class="line">    <span class="comment">//话说真的有人会抄我这么丑的代码吗（逃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈算法之递归</title>
      <link href="/2018/07/21/%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/"/>
      <url>/2018/07/21/%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>燥热的夏天几乎使我迷失了方向</p><p>这次的博客介绍的是基础算法“递归”，递归是算法竞赛中非常常用的基础技巧（<del>暴搜骗分好啊</del>），也是许多高级算法的基础。所以一定要从原理到编写方式熟练掌握。</p><p>然而递归的编写方式令人难以理解，可以说是初学者的第一道坎了。（笔者本人也在此研究了很久）。</p><p><strong>递归的定义：函数自己调用自己</strong></p><p><strong>笔者对递归的浅显理解： 通过把上一次的输出（进行一定处理）作为下一次的输入，重复做同一件事。不断缩小问题的规模，最终求得结果</strong></p><p>递归分为尾部递归（也称尾递归）和普通递归(也称中间递归），那么他们有什么区别呢</p><h3 id="尾部递归"><a href="#尾部递归" class="headerlink" title="尾部递归"></a>尾部递归</h3><p>我来讲个故事吧</p><p>从前有座山，山上有座庙，庙里有个老和尚，老和尚给小和尚讲故事。故事的内容是：从前有座山，山上有座庙，庙里有个老和尚，老和尚给小和尚讲故事。故事的内容是：从前有座山……</p><p>那为什么称之为尾部递归呢？因为在代码中，递归位于函数的尾部，也就是说下一个函数不再需要上一个函数的环境了，得出结果后会直接返回。</p><h3 id="中部递归"><a href="#中部递归" class="headerlink" title="中部递归"></a>中部递归</h3><p>我再讲个故事</p><p>从前有座山，山上有座庙，庙里有个老和尚，老和尚给小和尚讲故事。故事的内容是：……<br>小和尚受不了，跑了。</p><p>这就是中部递归，递归位于函数的中部，函数返回后需要继续处理。</p><p>笔者主观认为中部递归更难理解些，因此建议大家反复看看这个故事（其实没什么用），并找找其他的博客看看有什么能启发到自己的东西。</p><p>（需要说明的是，以上两个故事可能不是很严谨的递归，但是帮助理解足够了。）</p><h3 id="递归的特点"><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h3><p>优点是：逻辑简单清晰，代码可读性强<br>缺点是：过深的调用会导致爆栈</p><p>（本文配合搜索食用更佳）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈算法之快速排序</title>
      <link href="/2018/07/19/%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/19/%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>这两天集训了，想着不能再颓了，总得做些有意义的事。<br><br>于是重新配置一下许久没有动过的博客，<del>摸摸鱼</del> 好好复习一下之前学过的东西。</p><p>闲话少说，进入正题。</p><p><strong>快速排序</strong></p><p><strong><em>基本思想</em></strong></p><p>快速排序采用的是一种分治的思想。<br>它将待排序序列分成两个子序列。</p><p><strong><em>具体步骤</em></strong>：<br>1.从数列中挑出一个元素，称为基准，也可以形象地称它作“哨兵”（也就是在代码中看到名为”pivot”的东西）</p><p>2.将所有比基准值小的元素挪到基准前面，比基准大的挪到基准后面。那等于基准的呢？放在任意一边。</p><p>3.递归地将两个子序列再次排序。</p><p>有人问，这样什么时候结束呢？</p><p>递归到最底部的时候，子序列一定会被分成长度为0或1的序列，显然也就是排序好了。并且它一定会结束，因为每次迭代至少有一个元素到达了它最终的位置（就是可爱的哨兵啊）。</p><p>以上内容参考<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" title="快速排序-维基百科" target="_blank" rel="noopener">快速排序-维基百科</a></p><p>放一张图，更方便大家理解<br><img src="https://s1.ax2x.com/2018/07/19/wXmEi.jpg" alt="quicksort"><br>(图片转自<a href="http://www.cnblogs.com/CBDoctor/p/4077574.html" target="_blank" rel="noopener">http://www.cnblogs.com/CBDoctor/p/4077574.html</a>)</p><p><strong><em>实现方式</em></strong></p><p>然后接下来拿出我<del>丑的可怕</del>的代码，来学习一下快排的具体实现方式（其实有很多种实现方法，在此只举一个例子）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><span class="comment">//left，right代表的是待排序的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">int</span> mid = arr[(i+j)/<span class="number">2</span>];<span class="comment">//这就是pivot，建议随机一个以免被卡（其实并不会怎样）</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) <span class="comment">//这个while循环实现的是从哨兵左边找一个比哨兵大的数，从哨兵右边找一个比它小的数，若i，j未相遇则交换这两个值，直到i，j相遇</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt; mid) </span><br><span class="line">i ++;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt; mid) </span><br><span class="line">j --;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">            i ++;</span><br><span class="line">j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; right)<span class="comment">//只要哨兵右边还有数，就递归继续进行排序</span></span><br><span class="line">quickSort(i, right);</span><br><span class="line">    <span class="keyword">if</span>(left &lt; j)<span class="comment">//只要哨兵左边还有数，就递归继续进行排序</span></span><br><span class="line">quickSort(left, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的优缺点</strong><br>优点： 非常快速（在O（N*logN）的排序中常数小），为原址排序（不需要像归并一样的额外辅助空间）<br>缺点：不稳定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
