<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[P1378 油滴扩展]]></title>
    <url>%2F2019%2F12%2F11%2FP1378%2F</url>
    <content type="text"><![CDATA[链接Luogu 题解直接爆搜即可,每次放点的时候判断半径设为其他油滴相切或与边界相切(当然取最小值),放完所有点时更新最小值即可. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;const double PI = 3.1415926535898;int read()&#123; char c; int f = 1,ans = 0; do &#123; c = getchar(); if(c == '-') f = -1; &#125; while (c &lt; '0' || c &gt; '9'); do &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0'; c = getchar(); &#125; while (c &lt;= '9' &amp;&amp; c &gt;= '0'); return f * ans;&#125;struct node&#123; int x, y, r; node(int r = 0) : r(r) &#123;&#125;&#125; nodes[100];double rad[100];int n;double mins = 10000000.0;int vis[100];double dist(node a,node b)&#123; return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));&#125;double s(int i)&#123; double r = 100000000.0; for (int j = 2;j &lt; n+2;j ++) &#123; if(vis[j] &amp;&amp; j != i) &#123; r = std::min(r,std::max(dist(nodes[i],nodes[j])-rad[j],0.0)); &#125; &#125; r = std::min(r,(double)std::abs(nodes[0].x-nodes[i].x)); r = std::min(r,(double)std::abs(nodes[1].x-nodes[i].x)); r = std::min(r,(double)std::abs(nodes[0].y-nodes[i].y)); r = std::min(r,(double)std::abs(nodes[1].y-nodes[i].y)); rad[i] = r; return PI*r*r;&#125;void dfs(int k,double rest)&#123; if(k &gt; n - 1) &#123; //printf("%f %f\n",mins,rest); mins = std::min(mins,rest); return; &#125; for(int i = 2;i &lt; n + 2;i ++) &#123; if(vis[i]) continue; vis[i] = 1; dfs(k+1,rest-s(i)); vis[i] = 0; &#125;&#125;int main()&#123; n = read(); nodes[0].x = read(),nodes[0].y = read(); nodes[1].x = read(),nodes[1].y = read(); double S = std::abs((nodes[1].x-nodes[0].x)*(nodes[1].y-nodes[0].y)); for(int i = 2;i &lt; n + 2;i ++) &#123; nodes[i].x = read(); nodes[i].y = read(); &#125; dfs(0,S); int ans = mins+0.5; printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1514 引水入城]]></title>
    <url>%2F2019%2F12%2F10%2FP1514%2F</url>
    <content type="text"><![CDATA[链接Luogu 题解由第一排向最后一排DFS/BFS,记录第一排每个城市所能拓展到的干旱区城市的最左,最右端,第 $i$ 个城市用 $l[i],r[i]$ 表示. 先判断是否所有干旱区的城市都能建有水利设施,如果不是则直接输出0,再扫一遍有几个城市没有. 如果所有的都能,那么需要求蓄水厂的最小值 这里有一个结论:若所有干旱区城市都能建有水利设施,那么上面记录的第一排城市能扩展的干旱区城市一定是连续一个区间的,因为如果它不是连续的,那么中间断开的城市一定比它左右两个城市的引水路径中间的城市都高,那它就被封闭起来了,也就无法得到水,与所有干旱区城市都能建有水利设施的假设不符. 于是转换为了区间覆盖,可DP求解,用 $d(i)$ 表示覆盖前 $i$ 个干旱区城市需多少蓄水厂. 边界,最左端的线段覆盖的城市需要的蓄水厂数显然为1 $d(k) = 1,l[i]=0,l[i]&lt;=k&lt;=r[i]$ 状态转移方程 $d(i)= min(d(i),d(l[j]-1)+1),l[j]&lt;=i,r[j]&gt;=i$ 有个优化就是在搜索开始之前如果这个点已经被搜过了,那就不用搜了(后面走的一定跟之前一样). 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;const int MAXN = 500;const int MAXM = 500;int read()&#123; char c; int f=1,ans=0; do &#123;c=getchar(); if (c=='-')f=-1; &#125; while (c&lt;'0'||c&gt;'9'); do &#123;ans=(ans &lt;&lt; 3)+(ans&lt;&lt;1)+c-'0'; c=getchar(); &#125; while (c&gt;='0'&amp;&amp;c&lt;='9'); return f * ans;&#125;int dir[4][2] = &#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;int h[MAXN][MAXM];int vis[MAXN][MAXM];int l[MAXM],r[MAXM];int d[MAXM];int n, m;struct node&#123; int x, y; node(int x = 0,int y = 0) : x(x), y(y) &#123;&#125;&#125;;bool bfs(node s)&#123; std::queue&lt;node&gt; Q; Q.push(s); vis[s.x][s.y] = s.y+1; node cur; while (!Q.empty()) &#123; cur = Q.front(); Q.pop(); int&amp; x = cur.x,y = cur.y; for (int i = 0;i &lt; 4;i ++) &#123; int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (dx &lt; 0 || dx &gt;= n || dy &lt; 0 || dy &gt;= m) continue; if (h[dx][dy] &lt; h[x][y] &amp;&amp; vis[dx][dy] != s.y+1) &#123; vis[dx][dy] = s.y+1; Q.push(node(dx,dy)); &#125; &#125; &#125; for (int i = 0;i &lt; m;i ++) &#123; if (vis[n-1][i] == s.y+1) &#123; l[s.y] = i; break; &#125; &#125; for (int i = m - 1;i &gt;= 0;i --) &#123; if (vis[n-1][i] == s.y+1) &#123; r[s.y] = i; break; &#125; &#125; &#125;int main()&#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 0;i &lt; n;i ++) for (int j = 0;j &lt; m;j ++) h[i][j] = read(); memset(l,-1,sizeof(l)); for (int i = 0;i &lt; m;i ++) &#123; if(!vis[0][i]) bfs(node(0,i)); &#125; bool flag = true; int num = 0; for (int i = 0;i &lt; m;i ++) &#123; if (!vis[n-1][i]) &#123; flag = false; num ++; &#125; &#125; if (flag) &#123; printf("1\n"); memset(d,0x3f,sizeof(d)); for (int i = 0;i &lt; m;i ++) &#123; if (l[i] == 0) &#123; for (int j = l[i];j &lt;= r[i];j ++) &#123; d[j] = 1; &#125; &#125; &#125; for (int i = 0;i &lt; m;i ++) &#123; for (int j = 0;j &lt; m;j ++) &#123; if(l[j] &gt; 0 &amp;&amp; l[j] &lt;= i &amp;&amp; r[j] &gt;= i) &#123; d[i] = std::min(d[i],d[l[j]-1]+1); &#125; &#125; &#125; printf("%d\n",d[m-1]); &#125; else &#123; printf("0\n%d\n",num); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>搜索</tag>
        <tag>DP</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA11584 划分成回文串]]></title>
    <url>%2F2019%2F12%2F10%2FUVA11584%2F</url>
    <content type="text"><![CDATA[输入一个完全由小写字母构成的字符串,把它划分成尽量少的回文串,输出最小的回文串个数 链接Luogu Uva 题解用$d(i)$表示 $0$~$i$ 划分成的最小回文串的个数,那么初始值可设为最差情况,即为字符 $i$ 自己为一个回文串,$d(i) = d(i-1)+1$. 用一个布尔数组 $isPal(i)(j)$ 表示从 $i$ 到 $j$ 是一个回文串 状态转移方程为 $d(i) = d(j-1)+1 ,j &lt; i,isPal(j)(i)$ 现在考虑如何判断回文串,如果每次状态转移的时候都判断一次,时间复杂度会达到$O(n^3)$ 那么需要预处理回文串,可使用动态规划法,易知初始值为 $isPal(i)(i) = 1$ $isPal(i-1)(i)=1,s[i-1]=si$ 状态转移方程为 $isPal(i)(j) = isPal(i+1)(j-1),i&lt;j-1,s[i]=s[j]$ $isPal(i)(j)=false,s[i]!=s[j]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;const int MAXN = 1000+1;bool is_pal[MAXN][MAXN];int d[MAXN];int read()&#123; char c; int f = 1,ans = 0; do &#123; c = getchar(); if(c == '-') f = -1; &#125; while (c &lt; '0' || c &gt; '9'); do &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0'; c = getchar(); &#125; while (c &lt;= '9' &amp;&amp; c &gt;= '0'); return f * ans;&#125;void judge(std::string&amp; s,int len)&#123; /* for(int i = 0;i &lt; len;i ++) &#123; is_pal[i][i] = true; for(int l = 0;(i - l &gt;= 0) &amp;&amp; (i + l &lt; len);l ++) &#123; if(s[i-l] == s[i+l]) is_pal[i-l][i+l] = true; &#125; &#125;*/ for(int i = 0;i &lt; len;++ i) &#123; is_pal[i][i] = true; is_pal[i-1][i] = (s[i-1] == s[i]); &#125; for(int j = 1;j &lt; len;++ j) &#123; for(int i = 0;i &lt; j - 1;++ i) &#123; if(s[i] == s[j]) is_pal[i][j] = is_pal[i+1][j-1]; else is_pal[i][j]=false; &#125; &#125;&#125;int main()&#123; int T = read(); while (T --) &#123; memset(is_pal,0,sizeof(is_pal)); memset(d,0,sizeof(d)); std::string s; std::cin &gt;&gt; s; int len = s.length(); judge(s,len); d[0] = 1; for (int i = 0;i &lt; len;i ++) &#123; if(i &gt; 0) d[i] = d[i-1] + 1; for(int j = 0;j &lt; i;j ++) &#123; if(is_pal[j][i]) d[i] = std::min(d[i],d[j-1] + 1); &#125; &#125; printf("%d\n",d[len-1]); &#125;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA1025 城市里的间谍]]></title>
    <url>%2F2019%2F12%2F07%2FUVA1025%2F</url>
    <content type="text"><![CDATA[链接A spy in the metro Luogu 题解]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA437 巴比伦塔]]></title>
    <url>%2F2019%2F12%2F07%2FUVA437%2F</url>
    <content type="text"><![CDATA[用$n$ 种长方体堆出一座塔,每种长方体有无限个,当一个长方体的底面严格小于另一个长方体的底面时(可以选择任意一个面作为底面),这个长方体可以放在另一个长方体上面.求建出的塔的最大高度. 题解存储一种长方体的三种摆放方式,将一种长方体 $i$ (之前的一种长方体现在变成了三种)可以放在另一种长方体 $j$ 上面记为从 $i$ 向 $j$ 连一条边权为$i$的高度的有向边,则原问题可转换为DAG上的最长路求解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;const int N = 50;int read()&#123; char c; int f=1,ans=0; do &#123;c=getchar(); if (c=='-')f=-1; &#125; while (c&lt;'0'||c&gt;'9'); do &#123;ans=(ans &lt;&lt; 3)+(ans&lt;&lt;1)+c-'0'; c=getchar(); &#125; while (c&gt;='0'&amp;&amp;c&lt;='9'); return f * ans;&#125;int dp[3*N];int brick[3*N][3];int n;int d(int i)&#123; int&amp; ans = dp[i]; if(ans &gt; 0) return ans; ans = brick[i][2]; for(int j = 1;j &lt;= 3 * n;j ++) &#123; if((brick[i][0] &lt; brick[j][0] &amp;&amp; brick[i][1] &lt; brick[j][1])\ || (brick[i][0] &lt; brick[j][1] &amp;&amp; brick[i][1] &lt; brick[j][0])) &#123; ans = std::max(ans,d(j) + brick[i][2]); &#125; &#125; return ans;&#125;int main()&#123; int kase = 0; while (n = read()) &#123; memset(brick,0,sizeof(brick)); memset(dp,0,sizeof(dp)); int a[3]; for(int i = 1;i &lt;= 3 * n;i += 3) &#123; a[0] = read(),a[1] = read(),a[2] = read(); brick[i][0] = a[0], brick[i][1] = a[1], brick[i][2] = a[2]; brick[i+1][0] = a[1], brick[i+1][1] = a[2], brick[i+1][2] = a[0]; brick[i+2][0] = a[2], brick[i+2][1] = a[0], brick[i+2][2] = a[1]; &#125; int finalans = -1; for(int i = 1;i &lt;= 3 * n;i ++) &#123; finalans = std::max(finalans,d(i)); &#125; printf("Case %d: maximum height = %d\n",++ kase,finalans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>DAG上的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA116 单向TSP]]></title>
    <url>%2F2019%2F12%2F07%2FUVA116%2F</url>
    <content type="text"><![CDATA[给定一个 $m$ 行 $n$ 列的整数矩阵,从第一列任何一个位置出发每次往右,右上,右下走一格,最终到达最后一列任意位置.要求经过的整数之和最小.整个矩阵是环形的,即第一行的上一行是最后一行,最后一行的下一行是第一行.输出路径上每列的行号.多解时输出字典序最小的. 题解用$a(i,j)$表示矩阵中的数, $d(i,j)$ 表示当位于 $(i,j)$ 时到最后一列需要经过的整数之和的最小值. 根据题意, $d(i,j)$ 可从 $d(i+1,j+1)$,$d(i,j+1)$,$d(i-1,j+1)$. 转移来 其中当 $i=1$ 时 $i-1=m$,当$i=m$时$i+1=1$ 状态转移方程为 $d(i,j)=min(d(i+1,j+1),d(i,j+1),d(i+1,j+1))+a(i,j)$ 根据定义易知边界为$d(i,n) = a(i,n)$ 因为要输出路径,所以再开一个数组记录$(i,j)$的下一个点,具体见代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;const int M = 20;const int N = 200;const int INF = 0x3f3f3f3f;int read()&#123; char c; int f=1,ans=0; do &#123;c=getchar(); if (c=='-')f=-1; &#125; while (c&lt;'0'||c&gt;'9'); do &#123;ans=(ans &lt;&lt; 3)+(ans&lt;&lt;1)+c-'0'; c=getchar(); &#125; while (c&gt;='0'&amp;&amp;c&lt;='9'); return f * ans;&#125;int a[M][N];int ne[M][N];int d[M][N];int main()&#123; int m, n; while (~scanf("%d%d",&amp;m,&amp;n) &amp;&amp; m &amp;&amp; n) &#123; for (int i = 0;i &lt; m;i ++) for (int j = 0;j &lt; n;j ++) a[i][j] = read(); int ans = INF; int first; for (int j = n - 1;j &gt;= 0;j --) &#123; for (int i = 0;i &lt; m;i ++) &#123; if (j == n - 1) d[i][j] = a[i][j]; else &#123; int rows[3] = &#123;i,i - 1,i + 1&#125;; if (i == 0) rows[1] = m - 1; if (i == m - 1) rows[2] = 0; std::sort(rows,rows+3);//字典序 d[i][j] = INF; for (int k = 0;k &lt; 3;k ++) &#123; if (d[rows[k]][j+1] + a[i][j] &lt; d[i][j]) &#123; d[i][j] = d[rows[k]][j+1] + a[i][j]; ne[i][j] = rows[k]; &#125; &#125; &#125; if (j == 0 &amp;&amp; d[i][j] &lt; ans) &#123; first = i; ans = d[i][j]; &#125; &#125; &#125; printf("%d",first + 1); for (int i = ne[first][0],j = 1;j &lt; n;i = ne[i][j ++]) printf(" %d",i + 1); printf("\n%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA1347 旅行]]></title>
    <url>%2F2019%2F12%2F07%2FUVA1347%2F</url>
    <content type="text"><![CDATA[按$x$递增顺序给出$n$个点,设计一条从最左边的点出发到最右边的点再返回的路径,使得除了最左点与最右点之外每个点恰好经过一次,且路径总长度最短. 题解假设两个人同时从最左点出发,则用 $d(i,j)$ 表示$1-max(i,j)$ 全部走过,且两个人分别处于 $i,j$ 时到终点还要多长距离. 易知$d(i,j) = d(j,i)$ 则规定 $i &gt; j$ .因每个点都要走过,即不能跳过任何点,也就是 $i+1$ 一定会被$i$或$j$走到 则状态转移方程为 $d(i,j) = \min(d(i+1,j)+dist(i,i+1),d(i+1,i)+dist(j,i+1)$ 即 $i$ 走到 $i+1$ 或 $j$ 走到 $i+1$ . 最终答案为 $d(1,1)$ 或 $dist(1,2)+d(2,1)$,因为第一步必定是某人走到了 $2$ 点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define DEBUGconst int MAXN = 1000+10; struct Node&#123; int x, y;&#125; nodes[MAXN];int read()&#123; char c; int f=1,ans=0; do &#123; c=getchar(); if (c=='-')f=-1; &#125; while (c&lt;'0'||c&gt;'9'); do &#123; ans=(ans &lt;&lt; 3)+(ans&lt;&lt;1)+c-'0'; c=getchar(); &#125; while (c&gt;='0'&amp;&amp;c&lt;='9'); return f * ans;&#125;double dis[MAXN][MAXN];double f[MAXN][MAXN];double dist(int i,int j)&#123; if(dis[i][j] &gt; 0) return dis[i][j]; else &#123; double x = std::abs(nodes[i].x - nodes[j].x); double y = std::abs(nodes[i].y - nodes[j].y); dis[i][j] = sqrt(x*x+y*y); &#125; return dis[i][j];&#125;int n;double d(int i,int j)&#123; if(f[i][j] &gt; 0) return f[i][j]; f[i][j] = 0.0; if(i == n - 1) f[i][j] = dist(n-1,n) + dist(j,n); else f[i][j] = std::min(dist(i,i+1)+d(i+1,j),dist(j,i+1)+d(i+1,i)); return f[i][j];&#125;int main()&#123; while (~scanf("%d",&amp;n) &amp;&amp; n) &#123; for (int i = 0; i &lt; 1010; i++) for (int j = 0; j &lt; 1010; j++) &#123; dis[i][j] = -1.0; f[i][j] = -1.0; &#125; //上面的初值不写会WA for (int i = 1;i &lt;= n;i ++) &#123; scanf("%d%d",&amp;nodes[i].x,&amp;nodes[i].y); &#125; /* for (int i = 1;i &lt; n - 1;i ++) f[n-1][i] = dist(n-1,n) + dist(i,n); for(int i = n - 2;i &gt; 1;i --) &#123; for(int j = i - 1;j &gt; 0;j --) &#123; f[i][j] = std::min(dist(i,i+1)+f[i+1][j],dist(j,i+1)+f[i+1][i]); &#125; &#125; */ printf("%.2f\n",d(1,1));//dist(1,2)+f[2][1] &#125; return 0;&#125;//代码注释中为递推版]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1352 没有上司的舞会]]></title>
    <url>%2F2019%2F12%2F06%2FP1352%2F</url>
    <content type="text"><![CDATA[一棵树上儿子和父亲不能同时出现,求最大点权和 链接P1352 题解树形DP经典题,不妨用 $ f[i][0]$ 表示 $i$ 号不来时(下属来不来都可以)的最大快乐指数, $f[i][1]$ 表示 $i$ 号来时(下属一定都不来)的最大快乐指数 则 $f[x][0] = \Sigma({\max(f[v][0],f[v][1])}),v\in son[x]$ $f[x][1] = \Sigma(f[v][0])+w[x] ,v \in son[x]$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;int n;int w[6005];std::vector&lt;int&gt; son[6005];int f[6005][2];int in[6005];void dp(int r)&#123; f[r][0] = 0; f[r][1] = w[r]; for(int i = 0;i &lt; son[r].size();i ++) &#123; dp(son[r][i]); f[r][0] += std::max(f[son[r][i]][0],f[son[r][i]][1]); f[r][1] += f[son[r][i]][0]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i ++) &#123; scanf("%d",&amp;w[i]); &#125; for(int i = 1;i &lt;= n;i ++) &#123; int f,s; scanf("%d%d",&amp;s,&amp;f); son[f].push_back(s); in[s] ++; &#125; int root; for(int i = 1;i &lt;= n;i ++) &#123; if(!in[i]) &#123; root = i; break; &#125; &#125; dp(root); printf("%d",std::max(f[root][0],f[root][1])); &#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1462 通往奥格瑞玛的道路]]></title>
    <url>%2F2019%2F12%2F05%2FP1462%2F</url>
    <content type="text"><![CDATA[简要思路二分答案+最短路验证 点权为费用,所以只挑符合答案的点走,边权为血量,显然最短路是扣血最少的,所以可以用最短路 这个题意毒瘤,其实是求路径上的边权的最大值最小为多少(于是就是二分 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;int n,m,b;struct node&#123; int u,d; bool operator &lt;(const node&amp; rhs)const &#123; return d &gt; rhs.d; &#125;&#125;;struct edge&#123; int v,w;&#125;;int read()&#123; char c; int f = 1; int ans = 0; do &#123; c = getchar(); if(c == '-') f = -1; &#125; while(c &lt; '0' || c &gt; '9'); do &#123; ans = ans*10+c-'0'; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9'); return f*ans;&#125;std::vector&lt;edge&gt; G[10000+10];int N[10000+10];int dis[10000+10];void addEdge(int u,int v,int w)&#123; edge e; e.v = v,e.w = w; G[u].push_back(e);&#125;bool dijkstra(int M)&#123; int mx = -1; memset(dis,0x3f,sizeof(dis)); std::priority_queue&lt;node&gt; Q; node cur; dis[1] = 0; cur.u = 1,cur.d = 0; Q.push(cur); while(!Q.empty()) &#123; cur = Q.top(); Q.pop(); if(cur.d != dis[cur.u]) continue; for(register unsigned int i = 0;i &lt; G[cur.u].size();i ++) &#123; if(dis[cur.u]+G[cur.u][i].w &lt; dis[G[cur.u][i].v] &amp;&amp; N[G[cur.u][i].v] &lt;= M) &#123; dis[G[cur.u][i].v] = dis[cur.u]+G[cur.u][i].w; Q.push(&#123;G[cur.u][i].v,dis[G[cur.u][i].v]&#125;); &#125; &#125; &#125; if(dis[n] &lt; b) return true; else return false;&#125;int main()&#123; //freopen("1462.in","r",stdin); //freopen("1462.out","w",stdout); int mx = -1; n = read(),m = read(),b = read(); for(register int i = 1;i &lt;= n;i ++) &#123; N[i] = read(); mx = N[i] &gt; mx ? N[i] : mx; &#125; int u,v,w; for(register int i = 0;i &lt; m;i ++) &#123; u = read(),v = read(),w = read(); if(u != v) &#123; addEdge(u,v,w); addEdge(v,u,w); &#125; &#125; if(!dijkstra(0x3f3f3f3f)) &#123; printf("AFK"); return 0; &#125; int l = 0,r = mx+1,mid; while(l &lt;= r) &#123; mid = (l+r) &gt;&gt; 1; bool res = dijkstra(mid); if(res) r = mid - 1; else l = mid + 1; &#125; printf("%d",l); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP2019游记]]></title>
    <url>%2F2019%2F11%2F17%2FCSP2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[不知不觉中，就从无忧无虑的初中蒟蒻普及组选手经历了中考爆炸，变成了高一蒟蒻。 DAY0 周五为了赶去试机请了一天假，两小时高铁从沈阳赶到大连。中午跟队友们打了两盘三国杀，试机过程中旁边大佬聊的算法什么的都听不懂。晚上五人组团订了金拱门乐享三人餐x2，五个男人吃六人餐。酒店环境还蛮好的，有冰箱（虽然没什么用）和浴缸。 ​ 晚上室友用我的笔记本调了1h+的kruskal，我泡个澡出来他发现自己链式前向星第一句写的g[cnt++].u = u。边错位了… DAY1 早上酒店自助餐，我没什么可吃的于是搬空了迷你三明治。 8:25 听见监考还在研究怎么发题，顿感事情不妙。果然，发题出锅了，最后U盘传题，分片延时。我在的A区最早拿到题。 8:40 打开T1，格雷码。看了几分钟找到了规律。最后一位是0110，倒数第二位是00111100这样子的，然后从低位往高位枚举处理一下就好。但是慌得不行，怎么写怎么错。期间测试64的特判的时候还错把64 1当成了全0导致我以为自己程序输出最后一位是1出问题了。。。 于是我T1调了两小时，当场去世。 10:40 心凉的不行，迅速扫了一眼T2和T3，感觉T3链的分比较可做，然后就敲了50min左右，然而最后发现编号搞错了。我心灰意冷，犯下了另一个错误，放弃T3打开了T2。T3爆零 11:30 开搞T3，想了线段树之类的不会写，然后一看时间不足了（并且当时还以为没有延时），打个n^3的暴力拿点部分分也好。然而没有拿到，T2又爆0了。 ​ DAY1结束，出来发现有个队友忘了删文件注释了，惨。 DAY1.5 ​ 因为选手程序发的很快，所以下午就用手机在oitiku上测了一下，T1貌似是A了，然后T2T3果不其然地爆零。一看群里大众分210，感觉两天也拿不到210。 ​ 吃完饭在酒店里打狼人杀，队友表面老实实则各个十分精明，只有我一个人彻头彻尾地被骗得很惨。 ​ 晚上三人订了汉堡王，套餐香得不行。一边吃一边看《飞驰人生》，到结局室友在旁边我眼泪也在悄悄往下流，也许哪里有些共鸣。 DAY2 赛前毒奶：昨天都考两棵树了今天不能再考了，我都没学过树别这么对我。 打开题面：还来？？？ T1都不会了，感觉像DP然而没推出式子，想写记忆化搜索也没写出来。于是果断改写爆搜，写到一半第n次按下ctrl+s的时候系统提示存储空间不足。 存储空间不足？！我就写点代码加起来不到5k还能把硬盘写满？？？尝试删掉一些没用的东西，还是存不下我的代码。没办法，只得呼叫监考，最近的监考小姐姐完全束手无策，于是叫来了监考小哥哥，还是没用，监考叔叔也来了XD。删东西，重启皆无用，最后只能拿着u盘准备转移，然而考场电脑一插u盘就死机，好不容易搞定了，到新座位上一插发现还没拷出来…小哥哥重跑一趟，终于得救，然而这时候我的手已经在疯狂发抖了。 颤抖着调完T1，再次跳过T2去写了T3的链。与昨天完全一致…又是链，结果我今天又写炸了。光荣爆零。 ​ 考试结束，爆零x4。 oitiku和洛谷:100+0+0+32+0+0 = 132 赛前毒奶目标T1，结果真的只有T1有分，别的暴力都没写出来。 现在看来，自己明明有机会变强，从初二开始学OI，却在初中每日颓废，荒废了大把时光，现在去看学弟的博客什么的，也感到羡慕。可又有什么羡慕的呢?自己只是比他们环境稍差了些。 就算回到当时，没有一个教训将我打醒，也不会醒悟吧。 无论多么悔恨，也不会变强一分，只会离梦想越来越远。 既然如此，我还是去刷题吧。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtcoderBeginnerContest143]]></title>
    <url>%2F2019%2F10%2F21%2FABC143%2F</url>
    <content type="text"><![CDATA[ACurtain A-2B,小于0则取0 BTAKOYAKI FESTIVAL 2019 握手原理枚举每组takoyaki，累加其积。 CSlimes 连续相同字母的算一个 DTriangles 排序后枚举每种情况判断是否构成三角形（此时只需判断两小边之和大于大边） ETravel by Car 首先跑一遍Floyd求出所有点间的最短路，从而将最少需要加k次油的路（即每两点）分成k+1个点建图，在新生成的图上再次Floyd求出最短路。 之后对于每个询问给出输出。 FDistinct Numbers]]></content>
      <tags>
        <tag>AtCoder</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数学习笔记]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[向量(vector)2019.10.4 表示方式 几何表示：具有方向的线段叫做有向线段，向量为有向线段（在线性代数中，通常以原点为起点） $ \vec u=\begin{bmatrix}2 \\3 \\\end{bmatrix} $ 表示为图中箭头 坐标表示：有序的数字列表 \begin{bmatrix}a \\b \\\end{bmatrix}​ 如上二维向量代表由原点指向 (a,b) 的箭头，也就是从原点在x轴移动a“步”,再在y轴移动b“步”。多维同理 基础运算向量加法(vector addition) 三角形法则 将一个向量的起点移到另一个向量的终点，这两个向量的和为后者的起点指向前者的终点 ，多个向量同理 $ \vec u+\vec v=\vec w $ 所以 \begin{bmatrix}a \\b \\\end{bmatrix}+\begin{bmatrix}c \\d \\\end{bmatrix}=\begin{bmatrix}a+c \\b+d \\\end{bmatrix}相当于先在x轴移动 a+c “步”，再在y轴移动 b+d “步”，效果等同于在x轴移动 a “步”，在y轴移动 b “步”，再在x轴移动 c “步”，在y轴移动 d “步”。 向量数乘(vector multiplication by a number)对向量的缩放,用于控制缩放的量称为标量(scalar)，在这里通常可与数字(number)互相替换。 x\cdot\begin{bmatrix}a \\b \\\end{bmatrix} =\begin{bmatrix}xa \\xb\end{bmatrix}]]></content>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一种查询和修改复杂度都为 $\log(n)$ 的数据结构。可以通过前缀和的方式查询任意两个位置间所有元素和，即区间查询。朴素的树状数组支持单点修改。经简单修改借助差分可区间修改，单点查询。再多加辅助数组可实现区间修改，区间查询。 与线段树相似，相比之下线段树适用范围更广，而树状数组效率更高，代码更短。不过树状数组并不是真正的树形结构，而是树形结构思想的“数组”。 先码着 单点修改+区间查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;const int N = 500000+10;int C[N];int n;int lb(int i)&#123; return i&amp;-i;&#125;void add(int i,int k)//A[i]+=k,A为原数组&#123; while(i &lt;= n) &#123; C[i] += k; i += lb(i); &#125; return;&#125;int sum(int i)&#123; int ans = 0; while(i &gt; 0) &#123; ans += C[i]; i -= lb(i); &#125; return ans;&#125;int main()&#123; int m; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i ++) &#123; int x; scanf("%d",&amp;x); add(i,x); &#125; int t,a,b; for(int i = 1;i &lt;= m;i ++) &#123; scanf("%d%d%d",&amp;t,&amp;a,&amp;b); if(t == 1) &#123; add(a,b); &#125; else if(t == 2) &#123; int res = sum(b) - sum(a-1); printf("%d\n",res); &#125; &#125; return 0;&#125; 区间修改+单点查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;const int N = 500000+10;int C[N];int n;int lb(int i)&#123; return i&amp;-i;&#125;void add(int i,int k)&#123; while(i &lt;= n) &#123; C[i] += k; i += lb(i); &#125; return;&#125;long long qeury(int i)&#123; long long ans = 0; while(i &gt; 0) &#123; ans += C[i]; i -= lb(i); &#125; return ans;&#125;int main()&#123; int m; scanf("%d%d",&amp;n,&amp;m); int now,last = 0; for(int i = 1;i &lt;= n;i ++) &#123; scanf("%d",&amp;now); add(i,now-last); last = now; &#125; int t,a,b,k; for(int i = 1;i &lt;= m;i ++) &#123; scanf("%d",&amp;t); if(t == 1) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;k); add(a,k); add(b+1,-k); &#125; else if(t == 2) &#123; scanf("%d",&amp;a); long long res = qeury(a); printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高中每周刷题记录]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%AB%98%E4%B8%AD%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[201911.24-12.1P1198[JSOI2008]最大数 线段树 P1341无序字母对 欧拉路 P2023[AHOI2009]维护序列 线段树 11.18-11.24P3373[模板]线段树2双 lazytag 的线段树 P3372[模板]线段树1普通的线段树 P1972[SDOI2009]HH的项链 树状数组 P1120小木棍[数据加强版] 这个数据加强版卡掉了我DFS初值错误的程序(LOJ和UVA上的数据都没卡掉) UVA307小木棍Sticks 搜索 P2024[NOI2001]食物链 带偏移量的并查集 P2330[SCOI2005]繁忙的都市 最小生成树 P1546最短网络 Agri-Net 最小生成树 P1441砝码称重 DFS 11.11-11.17P1462通往奥格瑞玛的道路二分答案+最短路 P5650基础字符串练习题 这题我交了11次… P1144最短路计数 最短路(由于本题特殊性也可以bfs) CSP2019 D1T1格雷码 模拟?(结论题) J-T1数字游戏 入门题 11.04-11.1051nod猴猴吃苹果 洛谷P1091合唱队形 正反两次LIS 洛谷P1060开心的金明 01背包 洛谷P1010幂次方 递归 洛谷P1088火星人 下一个排列(next_permutation) 洛谷P1098字符串的展开 模拟 洛谷P1603斯诺登的密码 字符串 10.28-11.03洛谷P1038神经网络 拓扑排序 10.21-10.27洛谷P2661信息传递 DFS 最小环 洛谷P1032字串变换 BFS 字符串 10.14-10.20两天做了三场比赛里的签到题… CF594Div.2两道水题 AtCoderBeginnerContest143ABCD四道水题 XR-4歌唱比赛另一道大水模拟题 XR-4模拟赛水模拟题 10.7-10.13这周不见了orz 大概是因为月考 9.30-10.6洛谷P1087FBI树 洛谷P1030求先序序列 9.23-9.29洛谷P2058统计和 树状数组单点修改+区间查询 洛谷P1908逆序对 树状数组求逆序对 洛谷P3374[模板]树状数组1 树状数组单点修改+区间查询 洛谷P3368[模板]树状数组2 树状数组区间修改+单点查询 9.16-9.22洛谷P1082同余方程 9.9-9.15洛谷P1478陶陶摘苹果（升级版 排序 模拟 洛谷P1339[USACO09OCT]热浪Heat Wave 最短路 洛谷P1196[NOI2002]银河英雄传说 带权并查集 洛谷P1111修复公路 并查集 洛谷P1090合并果子 优先队列(小根堆) 9.2-9.8洛谷P1226【模板】快速幂||取余运算洛谷P1160队列安排 双向链表洛谷P1006传纸条 四维DP]]></content>
      <tags>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈算法之Dijkstra]]></title>
    <url>%2F2018%2F12%2F30%2FDijkstra%2F</url>
    <content type="text"><![CDATA[Dijkstra算法是典型的单源最短路径算法，也就是用于计算一个节点到其他节点的最短路径的算法。它的主要特点为以起始点中心，层层扩展。利用贪心的思想不断更新最短路。 算法主要思路取起点$s$，引入集合$S$和$U$，$S$中为已求出最短路径的节点（最短路径已确定），$U$中为未求出最短路径的节点。记节点$v$到$s$的距离为$dis[v]$ 易知初始时$S$中只有一个元素$s$，$dis[s]=0$，其余节点均在$U$中，$U$中与$s$相邻的节点到$s$的距离为边权，与$s$不相邻的节点到s的距离未知，视为$+\infty$。 此时从$U$中找到$dis[k]$最小的节点$k$，显然$k$的最短路径已求出，则将$k$从$U$中移到$S$中。 于是可以用$k$更新$U$中节点距离，由于与$k$相邻且不与$s$相邻的其它节点距离均为$+\infty$，故能更新。(实际实现中，称为松弛) 重复以上步骤，直至$U$为空集。 图解 （该图为LuoguP4779样例图示，graphviz制作） 工作量稍大先坑着了。 代码实现松弛，严格来讲并不属于最短路算法，却是该算法的核心部分 12if(dis[u]+G[u][i].w &lt; dis[v]) dis[v] = dis[u]+G[u][i].w//G[u][i]是一条从u指向v的边 堆优化代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using std::vector;using std::priority_queue;const int MAXN = 100010;const int MAXM = 200010;int dis[MAXN];int m,n,s;struct edge&#123; int u,v,w;&#125;;vector&lt;edge&gt; G[MAXM];struct node &#123; int u,d; bool operator &lt;(const node&amp; rhs) const &#123; return d&gt;rhs.d; &#125;&#125;;void addEdge(int u,int v,int w)&#123; edge newe; newe.u = u,newe.v = v,newe.w = w; G[u].push_back(newe);&#125;void dijkstra()&#123; for(int i = 1;i &lt;= n;i ++) dis[i] = 1000000000; dis[s] = 0; priority_queue&lt;node&gt; Q; Q.push((node)&#123;s,0&#125;); while(!Q.empty()) &#123; node nown = Q.top(); Q.pop(); int &amp;u = nown.u,&amp;d = nown.d; if(d != dis[u])//证明在此节点被取出之前u的最短路已被更新，则跳过这个节点 continue; for(int i = 0;i &lt; G[u].size();i ++) &#123; int &amp;w = G[u][i].w,&amp;v = G[u][i].v; if(dis[u]+G[u][i].w &lt; dis[v]) &#123; dis[v] = dis[u]+w; Q.push((node)&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i = 0;i &lt; m;i ++) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addEdge(u,v,w); &#125; dijkstra(); for(int i = 1;i &lt;= n;i ++) &#123; printf("%d ",dis[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈算法之Kruskal]]></title>
    <url>%2F2018%2F12%2F15%2FKruskal%2F</url>
    <content type="text"><![CDATA[mathjax: true Kruskal是一种被广泛使用的最小生成树算法，其实质为一种贪心算法。相比Prim来说，比较好写，用的人也比较多。首先我们需要知道最小生成树是个什么东西。 最小生成树严格定义可以自己百度，通俗来讲就是连通所有节点的总权值最小的树，或者说所有边权和最小的生成树，所以“最小生成树”应是“最小权重生成树”的简称。显然，非连通图中是没有最小生成树的。 算法过程将边按边权从小到大排序，从权值最小的边开始，依次将边加入，如果某条边所连接的两个点已经连通，也就是加入该边后会形成环，则跳过这条边，直至加入(结点数-1)条边。 算法证明首先感性理解下，在两个点已经连通的情况下，再加入连接这两条边的点的唯一作用就是凭空增加边权，所以不需要加该边。 证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。 基础：对于算法刚开始时，显然成立（最小生成树存在）。 归纳：假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。 如果 $e$ 属于 $T$，那么成立。 否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$（一定只有一条）。 首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。 然后，$f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。 所以，$T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。 引用内容摘自OI-wiki 算法具体实现根据上述过程，我们可以知道，需要的操作有判断两个点是否连通，朴素做法为O(n^2)的BFS，显然过慢。而且还需要连边，于是我们就想到了一个数据结构：并查集通过并查集，就可以做到查询两个点是否在同一棵树中和连接两棵树这些操作了。 读入后，对边按边权从小到大进行排序，下面代码中用的是结构体快排。 遍历排序后存边的数组，如果目前考虑的边的两个结点已经连通（处于同一个集合里），则跳过这条边考虑下一条。否则将这条边加入已选边中（即为将这条边的两个结点所在集合合并）。 当选择（结点数-1）条边时结束，此时已选边集合内为一颗最小生成树。 如果有空我会补图（我会持续咕咕咕的。 代码(直接把我LuoguP3366的AC代码拿过来了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::sort;const int MAXN = 5000 + 10;const int MAXM = 200000 + 10;struct edge&#123; int u,v,w;//u,v是两个点，w是边权&#125;;edge E[MAXM];bool cmpe(edge a,edge b)&#123; return a.w &lt; b.w;&#125;int n,m,tot;int uset[MAXN];void makeSet(int n)&#123; for(int i = 1;i &lt;= n;i ++) uset[i] = i; return;&#125;int find(int x)&#123; if(uset[x] != x) uset[x] = find(uset[x]); return uset[x];&#125;void unionSet(int x,int y)&#123; x = find(x),y = find(y); uset[y] = x;&#125;void kruskal(int i,int num)&#123; if(num == n-1) return; if(i &gt; m) &#123; tot = -1; return; &#125; if(find(E[i].u) == find(E[i].v)) &#123; kruskal(i+1,num); return; &#125; else &#123; unionSet(E[i].u,E[i].v); tot += E[i].w; kruskal(i+1,num+1); &#125; return;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); makeSet(n); for(int i = 1;i &lt;= m;i ++) &#123; scanf("%d%d%d",&amp;E[i].u,&amp;E[i].v,&amp;E[i].w); &#125; sort(E+1,E+m+1,cmpe); kruskal(1,0); if(tot == -1) printf("orz"); else printf("%d",tot); return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity学习心得]]></title>
    <url>%2F2018%2F10%2F29%2FUnity%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[近些天总算下定决心开始学习Unity，所以开篇博客来督促自己，记录每天的成果。Unity学习笔记 2018.1028&amp;29开始学习Unity，没找到什么入门资料，只能去官方网站看教程了。没想到教程质量还算可以，只不过大部分都是英文版，这时候才发现学英语是真的有用（逃。开始按照roll a ball教程学习。29日晚先看完了第一个视频，过几天也不一定再有这么多时间了，不知道多久才能把这个做完。总之，加油吧！ 31本来考虑买Unity3D和C#的书，后来上网看了一眼，实在没有什么有用的，不如硬啃官方文档。跟着教程写了个控制球移动的小脚本，虽然大部分是一知半解，但总算是写出来了。顺带着学了点C#的基础语法，浅显地理解了一点面向对象 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour &#123; public float speed; //通过将每帧移动的距离乘speed，可以控制移动速度， //定义成public即可在Unity中修改其值 private Rigidbody rb; void Start ()//脚本运行的第一帧会调用（通常是游戏运行的第一帧 &#123; rb = GetComponent&lt;Rigidbody&gt;(); //引用一个刚体组件，从而对这个刚体进行操作 &#125; void FixedUpdate ()//有关物理计算时会调用 &#123; float moveHorizontal = Input.GetAxis("Horizontal");//横轴移动的距离 float moveVertical = Input.GetAxis("Vertical");//纵轴移动的距离 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical);//三维向量 rb.AddForce(movement * speed);//此处省略了第二个变量，力的作用方式 &#125;&#125;//由于开始没有理解其工作方式，所以我弄了两个球体并都使用了这个脚本，结果是两个球都可以响应键盘的操作。//所以这个GetComponent引用这个脚本“所在”的GameObject的某个Component]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F10%2F13%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[初赛第一次参加NOIP，所以把初赛也写进来了。身为一个辽宁普及组选手，我没有zj大佬们的压力。赛前教练还半开玩笑地说着一分钟做完选择题然后看看读程序写结果就可以出来了（雾。然而我想着好歹也是第一次参加，还是待到结束比较好。于是我就蹭到了比赛结束（逃。同校的OIer简直有毒，我校都报的C++，结果他说他没练过C++，想报C，然后三十多分钟直接走了？？？个人感觉题并不是很难（然后我就GG了将近三十分，最后那个双向链表没看明白，我太鶸了。复赛见咯！辽宁说普及组不卡初赛，应该不会挂吧。（小声bb 复赛初赛结束后初赛结束后就是月考了，由于本校OI地位为0，所以完全没有时间搞OI（这时候我就想到复赛大概是凉凉了 Day1周六早晨坐高铁到了大连，由于时间比较紧，在火车站的肯德基简单吃了份早餐。高铁路程两个小时左右也没睡着，九点多下了高铁，出站的时候还看到了隔壁班的OIer，然后坐了一个多小时的出租车最终到了大连大学。下午两点左右开始试机，打了个快排模板发现调不出来，心里慌得一批…出来看了一眼快排 密码竟然充满了政治气息，看到的时候一脸懵看题的时候瞄了一眼机器配置，惊奇地发现CCF居然不是老爷机了？！ T1（比去年难多了，看到的时候还是有点慌，因为我忘了C++字符串的各种函数了…开始的时候想了一会多个换行符的问题，结果看到只有一行，不愧是第一题。最后用了getchar解决了 T2题面挺有意思，我用的龙虎两方气势差，因为long long而重构了一遍然而最后好像不知道怎么就写挂了，luogu测80分 T3看到题的时候想到是dp，但是我瞬间就明白了这不是我能a的题，然后开始写贪心…结果贪心调炸了，去写了一下T4(一会再说最后只拿了m=1的数据(凉凉 T4写这题的时候心态已经爆炸了， 于是写了这么个东西不知道能不能骗到分 估分100+80+10+ 0？ = 190估计没有省一了吧，估计是最菜的初三OIer了…然而有什么办法呢，退役是不可能退役的，只能接着肝了 ————2018.11.14]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的合并及查询问题。它支持两种操作： 查找 （Find）：确定某个元素处于哪个子集 合并 (Union)：将两个子集合合并成同一个集合 初始化 12345678void makeSet(int size)&#123; for(int i = 0;i &lt; size;i ++) &#123; fa[i] = i;//i就在它本身的集合里 &#125; return;&#125; 查找举个例子几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为“祖先”）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。在这样的思想下，并查集的查找诞生了。我们可以用代码模拟这个过程。（路径压缩等会再说） 1234567int fa[MAXN]; //记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己int find(int x) //寻找x的祖先&#123; if(fa[x] == x) //如果x是祖先则返回 return x; else return find(fa[x]); //如果不是则x的爸爸问x的爷爷&#125; 显然这样最终会返回x的祖先。 路径压缩这样的确可以达成目的，但是显然效率实在太低。为什么呢？因为我们使用了太多没用的信息，我关心的是我祖先是谁，我爸爸是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。把在路径上的每个节点都直接连接到根上，这就是路径压缩。于是用代码实现它。 123456int find(int x)&#123; if(x != fa[x])//x不是自身的父亲，即x不是该集合的代表 fa[x] = find(fa[x]);//查找x的祖先直到找到代表,于是顺手路径压缩 return fa[x];&#125; 合并宴会上，一个家族的祖先突然对另一个家族说:我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。我们之前说过，并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。 12345678void unionSet(int x,int y)//x与y所在家族合并&#123; x = find(x); y = find(y); if(x == y)//原本就在一个家族里就不管了 return; fa[x] = y;//把x的祖先变成y的祖先的儿子&#125; 启发式合并（选学）一个祖先突然抖了机灵：“你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。”启发式合并是将深度小的集合合并到深度大的集合（也成为按秩合并），或按照节点数量，这样还可以减少下次路径压缩的工作量。（反正启发式合并用得很少，路径压缩已经够快了。） 1234567891011int size[N];//记录子树的大小void unionSet(int x,int y)&#123; int xx = find(x),yy = find(y); if(xx == yy) return; if(size[xx] &gt; size[yy])//保证小的合到大的里 swap(xx,yy); fa[xx] = yy; size[yy] += size[xx];&#125; 时间复杂度及空间复杂度时间复杂度同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $ O(α(n)) $ ，其中α为反阿克曼函数，其增长极其缓慢，也就是说其平均运行时间可以认为是一个很小的常数。感兴趣的同学可以自行百科。 空间复杂度显然为 $ O(n) $ 其他应用最小生成树 Kruskal算法的优化 本文作者为JuicyMio，同时发表在OIwiki 除特别注明外，项目中除了代码部分均采用 (Creative Commons BY-SA 4.0) 知识共享署名-相同方式共享 4.0 国际许可协议 及附加的 The Star And Thank Author License 进行许可。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2049神、上帝以及老天爷]]></title>
    <url>%2F2018%2F07%2F24%2FHDU2049%2F</url>
    <content type="text"><![CDATA[做到这道题的时候没有搜到讲得比较好的题解(主要原因是这题太简单,而我太弱不会写 我正在写的这篇讲得也不好(逃,而且这道题所考察的错排问题也是我的盲点,于是赶紧上网搜索了一下,做完了题,简略地写个题解复习一下 言归正传,想要做这道题,要先了解”错排问题” 问题: 十本不同的书放在书架上。现重新摆放，使每本书都不在原来放的位置。有几种摆法? 这个问题推广一下，就是错排问题，是组合数学中的问题之一。考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。 错排问题最早被尼古拉·伯努利和欧拉研究，因此历史上也称为伯努利-欧拉的装错信封的问题。这个问题有许多具体的版本，如在写信时将n封信装到n个不同的信封里，有多少种全部装错信封的情况?又比如四人各写一张贺年卡互相赠送，有多少种赠送方法?自己写的贺年卡不能送给自己，所以也是典型的错排问题。 以上摘自百度百科 然后这个问题怎么解呢?其实百度百科上已经有详细的证明了(但是我没学会,所以就讲一下递推式的推导,对于这道题来说已经完全够用了。(以下参考自百度百科) 显然，D(1) = 0(因为根本没法错）,D(2) = 1。所以可以开始考虑n大于等于3的情况。那么我们设第n个元素放在了第k位(哪个元素都无所谓,就有两种情况 第k个元素放在第n位,也就是k,n互换,即他们两个已经完成错排了，那么又显然,问题与这两个元素无关了,变成了剩下的n-2个元素错排,也就是D(n-2) 第k个元素没放在第n位,再显然问题就变成了包括第k个元素在内的剩下(n-1)个元素的错排。即为D(n-1) 除第n个元素外每个元素都有D(n-1)+d(n-2)种放法，所以总放法 D(n) = n-1*(D(n-1)+D(n-2)) 错排问题还有通项公式，大家可以自行学习我说过我不会 掌握了这个，本题就很简单了本来就很简单，只需要算出错排数D(n)和总排列n!,再除一下弄成百分数就好了 （有一个小坑，正常人都能看出来，会爆int 上代码 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;const int MAXN = 21;long long d[MAXN];long long j[MAXN];int main()&#123; d[1] = 0;//没办法错 d[2] = 1;//只有互换 for(int i = 3;i &lt;= 20;i ++) &#123; d[i] = (i-1)*(d[i-1]+d[i-2]); &#125; j[0] = 1; for(int i = 1;i &lt;= 20;i ++) j[i] = j[i-1] * i; int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i ++) &#123; int t; scanf("%d",&amp;t); double ans = double(d[t])*100/double(j[t]); printf("%.2f%\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>错排问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载易懂的博客]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%BD%AC%E8%BD%BD%E6%98%93%E6%87%82%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[超有爱的并查集~]]></content>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1157心得]]></title>
    <url>%2F2018%2F07%2F24%2FP1157%2F</url>
    <content type="text"><![CDATA[只是一道dfs题，我做了半个小时左右。各种玄学错误，还有一些小细节处理不好，最后看到了一个题解指点迷津 大佬的题解1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#define mian mainint a[10000];int used[10000];int n,r;void dfs(int cnt)&#123; if(cnt == r+1)//非常有趣的做法，值得学习（是我太弱orz,为了避免负数的下标而把a[0]作为了一个起点，一个初始值而不是答案的一部分。只要多选一个数，然后在输出的时候直接无视掉a[0]就可以了 &#123; for(int i = 1;i &lt; cnt;i ++) printf("%3d",a[i]); printf("\n"); &#125; for(int i = a[cnt-1];i &lt;= n;i ++) &#123; if(!used[i]) &#123; used[i] = 1; a[cnt] = i; dfs(cnt+1); a[cnt] = 0; used[i] = 0; &#125; &#125;&#125;int mian()&#123; a[0] = 1; scanf("%d%d",&amp;n,&amp;r); dfs(1); return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P1926 小书童刷题大军]]></title>
    <url>%2F2018%2F07%2F24%2FP1926%2F</url>
    <content type="text"><![CDATA[第一次发题解 这题本蒟蒻纠结了好久,第一眼看上去像个01背包,但是我弱,我不会背包啊!于是我瞄了一眼数据范围,小的可怕2333,怪不得是橙题(那我还做那么久 暴搜显然能过,于是我调了一个小时的暴搜… 这两个东西怎么搜?把最短做完作业的时间搜出来再搜剩下时间能做多少题目？好像有点复杂了，后来分析一下，发现作业跟题目没有什么本质上的区别，只不过一个可以加题数，一个可以加分数。而本题要的又是保证分数的情况下要最大题数（这可不太好，有点本末倒置吧2333 所以可以把它们放在一起搜，就好写多了(主观认为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#define mian mainint a[1000][2];int n,m,k,r;int tot = 0,max = -1;void dfs(int step,int t,int g)//step通常用于控制当前要选择的元素 t时间 g分数&#123; if(step &lt; n+m)//只要选择没有做完（确定每个元素选或不选 &#123; if(t-a[step][0] &gt;= 0) //如果选了还没超时 &#123; if(step &lt; n)//如果选到的是题（因为题存在a[0]~a[n-1],则刷题数+1 tot ++; dfs(step+1,t-a[step][0],g+a[step][1]);//选 if(step &lt; n)//如果之前加过了，还要在出口减回来 tot --; &#125; dfs(step+1,t,g);//当然可以不做这道题/作业 &#125; else &#123; if(g&gt;=k &amp;&amp; t&gt;=0)//及格并且没有超时 max = std::max(max,tot); //tot = 0;这个地方为什么不能清0，因为回溯还要用到 //而且之前选了之后递归的出口已经减回去了（这个地方我调了好久 return; &#125; return;&#125;int mian()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;r); for(int i = 0;i &lt; n+m; i++)//放在一起存 &#123; scanf("%d",&amp;a[i][0]); &#125; for(int i = n;i &lt; n+m;i ++)//从n往后就是有分数的作业 &#123; scanf("%d",&amp;a[i][1]); &#125; dfs(0,r,0);//数组是从0从开始存放的，所以step也从0开始（个人习惯而已 printf("%d",max); return 0; //拒绝抄袭，从我做起 //话说真的有人会抄我这么丑的代码吗（逃&#125;]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
</search>
