<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性代数学习笔记]]></title>
    <url>%2F2019%2F10%2F04%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[向量(vector)2019.10.4 表示方式 几何表示：具有方向的线段叫做有向线段，向量为有向线段（在线性代数中，通常以原点为起点） $ \vec u=\begin{bmatrix}2 \\3 \\\end{bmatrix} $ 表示为图中箭头 坐标表示：有序的数字列表 \begin{bmatrix}a \\b \\\end{bmatrix}​ 如上二维向量代表由原点指向 (a,b) 的箭头，也就是从原点在x轴移动a“步”,再在y轴移动b“步”。多维同理 基础运算向量加法(vector addition) 三角形法则 将一个向量的起点移到另一个向量的终点，这两个向量的和为后者的起点指向前者的终点 ，多个向量同理 $ \vec u+\vec v=\vec w $ 所以 \begin{bmatrix}a \\b \\\end{bmatrix}+\begin{bmatrix}c \\d \\\end{bmatrix}=\begin{bmatrix}a+c \\b+d \\\end{bmatrix}相当于先在x轴移动 a+c “步”，再在y轴移动 b+d “步”，效果等同于在x轴移动 a “步”，在y轴移动 b “步”，再在x轴移动 c “步”，在y轴移动 d “步”。 向量数乘(vector multiplication by a number)对向量的缩放,用于控制缩放的量称为标量(scalar)，在这里通常可与数字(number)互相替换。 x\cdot\begin{bmatrix}a \\b \\\end{bmatrix} =\begin{bmatrix}xa \\xb\end{bmatrix}]]></content>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一种查询和修改复杂度都为 $\log(n)$ 的数据结构。可以通过前缀和的方式查询任意两个位置间所有元素和，即区间查询。朴素的树状数组支持单点修改。经简单修改借助差分可区间修改，单点查询。再多加辅助数组可实现区间修改，区间查询。 与线段树相似，相比之下线段树适用范围更广，而树状数组效率更高，代码更短。不过树状数组并不是真正的树形结构，而是树形结构思想的“数组”。 先码着 单点修改+区间查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;const int N = 500000+10;int C[N];int n;int lb(int i)&#123; return i&amp;-i;&#125;void add(int i,int k)//A[i]+=k,A为原数组&#123; while(i &lt;= n) &#123; C[i] += k; i += lb(i); &#125; return;&#125;int sum(int i)&#123; int ans = 0; while(i &gt; 0) &#123; ans += C[i]; i -= lb(i); &#125; return ans;&#125;int main()&#123; int m; scanf("%d%d",&amp;n,&amp;m); for(int i = 1;i &lt;= n;i ++) &#123; int x; scanf("%d",&amp;x); add(i,x); &#125; int t,a,b; for(int i = 1;i &lt;= m;i ++) &#123; scanf("%d%d%d",&amp;t,&amp;a,&amp;b); if(t == 1) &#123; add(a,b); &#125; else if(t == 2) &#123; int res = sum(b) - sum(a-1); printf("%d\n",res); &#125; &#125; return 0;&#125; 区间修改+单点查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;const int N = 500000+10;int C[N];int n;int lb(int i)&#123; return i&amp;-i;&#125;void add(int i,int k)&#123; while(i &lt;= n) &#123; C[i] += k; i += lb(i); &#125; return;&#125;long long qeury(int i)&#123; long long ans = 0; while(i &gt; 0) &#123; ans += C[i]; i -= lb(i); &#125; return ans;&#125;int main()&#123; int m; scanf("%d%d",&amp;n,&amp;m); int now,last = 0; for(int i = 1;i &lt;= n;i ++) &#123; scanf("%d",&amp;now); add(i,now-last); last = now; &#125; int t,a,b,k; for(int i = 1;i &lt;= m;i ++) &#123; scanf("%d",&amp;t); if(t == 1) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;k); add(a,k); add(b+1,-k); &#125; else if(t == 2) &#123; scanf("%d",&amp;a); long long res = qeury(a); printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高中每周刷题记录]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%AB%98%E4%B8%AD%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[20199.23-9.29洛谷P2058统计和 树状数组单点修改+区间查询 洛谷P1908逆序对 树状数组求逆序对 洛谷P3374[模板]树状数组1 树状数组单点修改+区间查询 洛谷P3368[模板]树状数组2 树状数组区间修改+单点查询 9.16-9.22洛谷P1082同余方程 9.9-9.15洛谷P1478陶陶摘苹果（升级版 排序 模拟 洛谷P1339[USACO09OCT]热浪Heat Wave 最短路 洛谷P1196[NOI2002]银河英雄传说 带权并查集 洛谷P1111修复公路 并查集 洛谷P1090合并果子 优先队列(小根堆) 9.2-9.8洛谷P1226【模板】快速幂||取余运算洛谷P1160队列安排 双向链表洛谷P1006传纸条 四维DP]]></content>
      <tags>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈算法之Dijkstra]]></title>
    <url>%2F2018%2F12%2F30%2FDijkstra%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈算法之Kruskal]]></title>
    <url>%2F2018%2F12%2F15%2FKruskal%2F</url>
    <content type="text"><![CDATA[mathjax: true Kruskal是一种被广泛使用的最小生成树算法，其实质为一种贪心算法。相比Prim来说，比较好写，用的人也比较多。首先我们需要知道最小生成树是个什么东西。 最小生成树严格定义可以自己百度，通俗来讲就是连通所有节点的总权值最小的树，或者说所有边权和最小的生成树，所以“最小生成树”应是“最小权重生成树”的简称。显然，非连通图中是没有最小生成树的。 算法过程将边按边权从小到大排序，从权值最小的边开始，依次将边加入，如果某条边所连接的两个点已经连通，也就是加入该边后会形成环，则跳过这条边，直至加入(结点数-1)条边。 算法证明首先感性理解下，在两个点已经连通的情况下，再加入连接这两条边的点的唯一作用就是凭空增加边权，所以不需要加该边。 证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。 基础：对于算法刚开始时，显然成立（最小生成树存在）。 归纳：假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。 如果 $e$ 属于 $T$，那么成立。 否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$（一定只有一条）。 首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。 然后，$f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。 所以，$T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。 引用内容摘自OI-wiki 算法具体实现根据上述过程，我们可以知道，需要的操作有判断两个点是否连通，朴素做法为O(n^2)的BFS，显然过慢。而且还需要连边，于是我们就想到了一个数据结构：并查集通过并查集，就可以做到查询两个点是否在同一棵树中和连接两棵树这些操作了。 读入后，对边按边权从小到大进行排序，下面代码中用的是结构体快排。 遍历排序后存边的数组，如果目前考虑的边的两个结点已经连通（处于同一个集合里），则跳过这条边考虑下一条。否则将这条边加入已选边中（即为将这条边的两个结点所在集合合并）。 当选择（结点数-1）条边时结束，此时已选边集合内为一颗最小生成树。 如果有空我会补图（我会持续咕咕咕的。 代码(直接把我LuoguP3366的AC代码拿过来了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::sort;const int MAXN = 5000 + 10;const int MAXM = 200000 + 10;struct edge&#123; int u,v,w;//u,v是两个点，w是边权&#125;;edge E[MAXM];bool cmpe(edge a,edge b)&#123; return a.w &lt; b.w;&#125;int n,m,tot;int uset[MAXN];void makeSet(int n)&#123; for(int i = 1;i &lt;= n;i ++) uset[i] = i; return;&#125;int find(int x)&#123; if(uset[x] != x) uset[x] = find(uset[x]); return uset[x];&#125;void unionSet(int x,int y)&#123; x = find(x),y = find(y); uset[y] = x;&#125;void kruskal(int i,int num)&#123; if(num == n-1) return; if(i &gt; m) &#123; tot = -1; return; &#125; if(find(E[i].u) == find(E[i].v)) &#123; kruskal(i+1,num); return; &#125; else &#123; unionSet(E[i].u,E[i].v); tot += E[i].w; kruskal(i+1,num+1); &#125; return;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); makeSet(n); for(int i = 1;i &lt;= m;i ++) &#123; scanf("%d%d%d",&amp;E[i].u,&amp;E[i].v,&amp;E[i].w); &#125; sort(E+1,E+m+1,cmpe); kruskal(1,0); if(tot == -1) printf("orz"); else printf("%d",tot); return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity学习心得]]></title>
    <url>%2F2018%2F10%2F29%2FUnity%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[近些天总算下定决心开始学习Unity，所以开篇博客来督促自己，记录每天的成果。Unity学习笔记 2018.1028&amp;29开始学习Unity，没找到什么入门资料，只能去官方网站看教程了。没想到教程质量还算可以，只不过大部分都是英文版，这时候才发现学英语是真的有用（逃。开始按照roll a ball教程学习。29日晚先看完了第一个视频，过几天也不一定再有这么多时间了，不知道多久才能把这个做完。总之，加油吧！ 31本来考虑买Unity3D和C#的书，后来上网看了一眼，实在没有什么有用的，不如硬啃官方文档。跟着教程写了个控制球移动的小脚本，虽然大部分是一知半解，但总算是写出来了。顺带着学了点C#的基础语法，浅显地理解了一点面向对象 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayerController : MonoBehaviour &#123; public float speed; //通过将每帧移动的距离乘speed，可以控制移动速度， //定义成public即可在Unity中修改其值 private Rigidbody rb; void Start ()//脚本运行的第一帧会调用（通常是游戏运行的第一帧 &#123; rb = GetComponent&lt;Rigidbody&gt;(); //引用一个刚体组件，从而对这个刚体进行操作 &#125; void FixedUpdate ()//有关物理计算时会调用 &#123; float moveHorizontal = Input.GetAxis("Horizontal");//横轴移动的距离 float moveVertical = Input.GetAxis("Vertical");//纵轴移动的距离 Vector3 movement = new Vector3(moveHorizontal, 0.0f, moveVertical);//三维向量 rb.AddForce(movement * speed);//此处省略了第二个变量，力的作用方式 &#125;&#125;//由于开始没有理解其工作方式，所以我弄了两个球体并都使用了这个脚本，结果是两个球都可以响应键盘的操作。//所以这个GetComponent引用这个脚本“所在”的GameObject的某个Component]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F10%2F13%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[初赛第一次参加NOIP，所以把初赛也写进来了。身为一个辽宁普及组选手，我没有zj大佬们的压力。赛前教练还半开玩笑地说着一分钟做完选择题然后看看读程序写结果就可以出来了（雾。然而我想着好歹也是第一次参加，还是待到结束比较好。于是我就蹭到了比赛结束（逃。同校的OIer简直有毒，我校都报的C++，结果他说他没练过C++，想报C，然后三十多分钟直接走了？？？个人感觉题并不是很难（然后我就GG了将近三十分，最后那个双向链表没看明白，我太鶸了。复赛见咯！辽宁说普及组不卡初赛，应该不会挂吧。（小声bb 复赛初赛结束后初赛结束后就是月考了，由于本校OI地位为0，所以完全没有时间搞OI（这时候我就想到复赛大概是凉凉了 Day1周六早晨坐高铁到了大连，由于时间比较紧，在火车站的肯德基简单吃了份早餐。高铁路程两个小时左右也没睡着，九点多下了高铁，出站的时候还看到了隔壁班的OIer，然后坐了一个多小时的出租车最终到了大连大学。下午两点左右开始试机，打了个快排模板发现调不出来，心里慌得一批…出来看了一眼快排 密码竟然充满了政治气息，看到的时候一脸懵看题的时候瞄了一眼机器配置，惊奇地发现CCF居然不是老爷机了？！ T1（比去年难多了，看到的时候还是有点慌，因为我忘了C++字符串的各种函数了…开始的时候想了一会多个换行符的问题，结果看到只有一行，不愧是第一题。最后用了getchar解决了 T2题面挺有意思，我用的龙虎两方气势差，因为long long而重构了一遍然而最后好像不知道怎么就写挂了，luogu测80分 T3看到题的时候想到是dp，但是我瞬间就明白了这不是我能a的题，然后开始写贪心…结果贪心调炸了，去写了一下T4(一会再说最后只拿了m=1的数据(凉凉 T4写这题的时候心态已经爆炸了， 于是写了这么个东西不知道能不能骗到分 估分100+80+10+ 0？ = 190估计没有省一了吧，估计是最菜的初三OIer了…然而有什么办法呢，退役是不可能退役的，只能接着肝了 ————2018.11.14]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的合并及查询问题。它支持两种操作： 查找 （Find）：确定某个元素处于哪个子集 合并 (Union)：将两个子集合合并成同一个集合 初始化 12345678void makeSet(int size)&#123; for(int i = 0;i &lt; size;i ++) &#123; fa[i] = i;//i就在它本身的集合里 &#125; return;&#125; 查找举个例子几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为“祖先”）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。在这样的思想下，并查集的查找诞生了。我们可以用代码模拟这个过程。（路径压缩等会再说） 1234567int fa[MAXN]; //记录某个人的爸爸是谁，特别规定，祖先的爸爸是他自己int find(int x) //寻找x的祖先&#123; if(fa[x] == x) //如果x是祖先则返回 return x; else return find(fa[x]); //如果不是则x的爸爸问x的爷爷&#125; 显然这样最终会返回x的祖先。 路径压缩这样的确可以达成目的，但是显然效率实在太低。为什么呢？因为我们使用了太多没用的信息，我关心的是我祖先是谁，我爸爸是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。把在路径上的每个节点都直接连接到根上，这就是路径压缩。于是用代码实现它。 123456int find(int x)&#123; if(x != fa[x])//x不是自身的父亲，即x不是该集合的代表 fa[x] = find(fa[x]);//查找x的祖先直到找到代表,于是顺手路径压缩 return fa[x];&#125; 合并宴会上，一个家族的祖先突然对另一个家族说:我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。我们之前说过，并不在意祖先究竟是谁，所以只要其中一个祖先变成另一个祖先的儿子就可以了。 12345678void unionSet(int x,int y)//x与y所在家族合并&#123; x = find(x); y = find(y); if(x == y)//原本就在一个家族里就不管了 return; fa[x] = y;//把x的祖先变成y的祖先的儿子&#125; 启发式合并（选学）一个祖先突然抖了机灵：“你们家族人比较少，搬家到我们家族里比较方便，我们要是搬过去的话太费事了。”启发式合并是将深度小的集合合并到深度大的集合（也成为按秩合并），但是笔者认为这样做的话路径压缩之后它就失去意义了，或按照节点数量，这样还可以减少下次路径压缩的工作量。（反正启发式合并用得很少，路径压缩已经够快了。） 1234567891011int size[N];//记录子树的大小void unionSet(int x,int y)&#123; int xx = find(x),yy = find(y); if(xx == yy) return; if(size[xx] &gt; size[yy])//保证小的合到大的里 swap(xx,yy); fa[xx] = yy; size[yy] += size[xx];&#125; 时间复杂度及空间复杂度时间复杂度同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $ O(α(n)) $ ，其中α为反阿克曼函数，其增长极其缓慢，也就是说其平均运行时间可以认为是一个很小的常数。感兴趣的同学可以自行百科。 空间复杂度显然为 $ O(n) $ 其他应用最小生成树 Kruskal算法的优化 本文作者为JuicyMio，同时发表在OIwiki 除特别注明外，项目中除了代码部分均采用 (Creative Commons BY-SA 4.0) 知识共享署名-相同方式共享 4.0 国际许可协议 及附加的 The Star And Thank Author License 进行许可。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2049神、上帝以及老天爷题解及错排问题]]></title>
    <url>%2F2018%2F07%2F24%2FHDU2049%E7%A5%9E%E3%80%81%E4%B8%8A%E5%B8%9D%E4%BB%A5%E5%8F%8A%E8%80%81%E5%A4%A9%E7%88%B7%E9%A2%98%E8%A7%A3%E5%8F%8A%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mathjax: true 做到这道题的时候没有搜到讲得比较好的题解(主要原因是这题太简单,而我太弱不会写 我正在写的这篇讲得也不好(逃,而且这道题所考察的错排问题也是我的盲点,于是赶紧上网搜索了一下,做完了题,简略地写个题解复习一下 言归正传,想要做这道题,要先了解”错排问题” 问题: 十本不同的书放在书架上。现重新摆放，使每本书都不在原来放的位置。有几种摆法? 这个问题推广一下，就是错排问题，是组合数学中的问题之一。考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。 错排问题最早被尼古拉·伯努利和欧拉研究，因此历史上也称为伯努利-欧拉的装错信封的问题。这个问题有许多具体的版本，如在写信时将n封信装到n个不同的信封里，有多少种全部装错信封的情况?又比如四人各写一张贺年卡互相赠送，有多少种赠送方法?自己写的贺年卡不能送给自己，所以也是典型的错排问题。 以上摘自百度百科 然后这个问题怎么解呢?其实百度百科上已经有详细的证明了(但是我没学会,所以就讲一下递推式的推导,对于这道题来说已经完全够用了。(以下参考自百度百科) 显然，D(1) = 0(因为根本没法错）,D(2) = 1。所以可以开始考虑n大于等于3的情况。那么我们设第n个元素放在了第k位(哪个元素都无所谓,就有两种情况 第k个元素放在第n位,也就是k,n互换,即他们两个已经完成错排了，那么又显然,问题与这两个元素无关了,变成了剩下的n-2个元素错排,也就是D(n-2) 第k个元素没放在第n位,再显然问题就变成了包括第k个元素在内的剩下(n-1)个元素的错排。即为D(n-1) 除第n个元素外每个元素都有D(n-1)+d(n-2)种放法，所以总放法 D(n) = n-1*(D(n-1)+D(n-2)) 错排问题还有通项公式，大家可以自行学习我说过我不会 掌握了这个，本题就很简单了本来就很简单，只需要算出错排数D(n)和总排列n!,再除一下弄成百分数就好了 （有一个小坑，正常人都能看出来，会爆int 上代码 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;const int MAXN = 21;long long d[MAXN];long long j[MAXN];int main()&#123; d[1] = 0;//没办法错 d[2] = 1;//只有互换 for(int i = 3;i &lt;= 20;i ++) &#123; d[i] = (i-1)*(d[i-1]+d[i-2]); &#125; j[0] = 1; for(int i = 1;i &lt;= 20;i ++) j[i] = j[i-1] * i; int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i ++) &#123; int t; scanf("%d",&amp;t); double ans = double(d[t])*100/double(j[t]); printf("%.2f%\n",ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[转载易懂的博客]]></title>
    <url>%2F2018%2F07%2F24%2F%E8%BD%AC%E8%BD%BD%E6%98%93%E6%87%82%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[超有爱的并查集~]]></content>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1157心得]]></title>
    <url>%2F2018%2F07%2F24%2FLuoguP1157%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[只是一道dfs题，我做了半个小时左右。各种玄学错误，还有一些小细节处理不好，最后看到了一个题解指点迷津 大佬的题解1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#define mian mainint a[10000];int used[10000];int n,r;void dfs(int cnt)&#123; if(cnt == r+1)//非常有趣的做法，值得学习（是我太弱orz,为了避免负数的下标而把a[0]作为了一个起点，一个初始值而不是答案的一部分。只要多选一个数，然后在输出的时候直接无视掉a[0]就可以了 &#123; for(int i = 1;i &lt; cnt;i ++) printf("%3d",a[i]); printf("\n"); &#125; for(int i = a[cnt-1];i &lt;= n;i ++) &#123; if(!used[i]) &#123; used[i] = 1; a[cnt] = i; dfs(cnt+1); a[cnt] = 0; used[i] = 0; &#125; &#125;&#125;int mian()&#123; a[0] = 1; scanf("%d%d",&amp;n,&amp;r); dfs(1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LuoguP1926【小书童--刷题大军】题解]]></title>
    <url>%2F2018%2F07%2F24%2FLuoguP1926%E3%80%90%E5%B0%8F%E4%B9%A6%E7%AB%A5-%E5%88%B7%E9%A2%98%E5%A4%A7%E5%86%9B%E3%80%91%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[第一次发题解，欢迎拍砖，拒绝杠精 这题本蒟蒻纠结了好久,第一眼看上去像个01背包,但是我弱,我不会背包啊!于是我瞄了一眼数据范围,小的可怕2333,怪不得是橙题(那我还做那么久 暴搜显然能过,于是我调了一个小时的暴搜… 这两个东西怎么搜?把最短做完作业的时间搜出来再搜剩下时间能做多少题目？好像有点复杂了，后来分析一下，发现作业跟题目没有什么本质上的区别，只不过一个可以加题数，一个可以加分数。而本题要的又是保证分数的情况下要最大题数（这可不太好，有点本末倒置吧2333 所以可以把它们放在一起搜，就好写多了(主观认为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#define mian mainint a[1000][2];int n,m,k,r;int tot = 0,max = -1;void dfs(int step,int t,int g)//step通常用于控制当前要选择的元素 t时间 g分数&#123; if(step &lt; n+m)//只要选择没有做完（确定每个元素选或不选 &#123; if(t-a[step][0] &gt;= 0) //如果选了还没超时 &#123; if(step &lt; n)//如果选到的是题（因为题存在a[0]~a[n-1],则刷题数+1 tot ++; dfs(step+1,t-a[step][0],g+a[step][1]);//选 if(step &lt; n)//如果之前加过了，还要在出口减回来 tot --; &#125; dfs(step+1,t,g);//当然可以不做这道题/作业 &#125; else &#123; if(g&gt;=k &amp;&amp; t&gt;=0)//及格并且没有超时 max = std::max(max,tot); //tot = 0;这个地方为什么不能清0，因为回溯还要用到 //而且之前选了之后递归的出口已经减回去了（这个地方我调了好久 return; &#125; return;&#125;int mian()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;r); for(int i = 0;i &lt; n+m; i++)//放在一起存 &#123; scanf("%d",&amp;a[i][0]); &#125; for(int i = n;i &lt; n+m;i ++)//从n往后就是有分数的作业 &#123; scanf("%d",&amp;a[i][1]); &#125; dfs(0,r,0);//数组是从0从开始存放的，所以step也从0开始（个人习惯而已 printf("%d",max); return 0; //拒绝抄袭，从我做起 //话说真的有人会抄我这么丑的代码吗（逃&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈算法之递归]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[燥热的夏天几乎使我迷失了方向 这次的博客介绍的是基础算法“递归”，递归是算法竞赛中非常常用的基础技巧（暴搜骗分好啊），也是许多高级算法的基础。所以一定要从原理到编写方式熟练掌握。 然而递归的编写方式令人难以理解，可以说是初学者的第一道坎了。（笔者本人也在此研究了很久）。 递归的定义：函数自己调用自己 笔者对递归的浅显理解： 通过把上一次的输出（进行一定处理）作为下一次的输入，重复做同一件事。不断缩小问题的规模，最终求得结果 递归分为尾部递归（也称尾递归）和普通递归(也称中间递归），那么他们有什么区别呢 尾部递归我来讲个故事吧 从前有座山，山上有座庙，庙里有个老和尚，老和尚给小和尚讲故事。故事的内容是：从前有座山，山上有座庙，庙里有个老和尚，老和尚给小和尚讲故事。故事的内容是：从前有座山…… 那为什么称之为尾部递归呢？因为在代码中，递归位于函数的尾部，也就是说下一个函数不再需要上一个函数的环境了，得出结果后会直接返回。 中部递归我再讲个故事 从前有座山，山上有座庙，庙里有个老和尚，老和尚给小和尚讲故事。故事的内容是：……小和尚受不了，跑了。 这就是中部递归，递归位于函数的中部，函数返回后需要继续处理。 笔者主观认为中部递归更难理解些，因此建议大家反复看看这个故事（其实没什么用），并找找其他的博客看看有什么能启发到自己的东西。 （需要说明的是，以上两个故事可能不是很严谨的递归，但是帮助理解足够了。） 递归的特点优点是：逻辑简单清晰，代码可读性强缺点是：过深的调用会导致爆栈 （本文配合搜索食用更佳）]]></content>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈算法之快速排序]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%B5%85%E8%B0%88%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这两天集训了，想着不能再颓了，总得做些有意义的事。于是重新配置一下许久没有动过的博客，摸摸鱼 好好复习一下之前学过的东西。 闲话少说，进入正题。 快速排序 基本思想 快速排序采用的是一种分治的思想。它将待排序序列分成两个子序列。 具体步骤：1.从数列中挑出一个元素，称为基准，也可以形象地称它作“哨兵”（也就是在代码中看到名为”pivot”的东西） 2.将所有比基准值小的元素挪到基准前面，比基准大的挪到基准后面。那等于基准的呢？放在任意一边。 3.递归地将两个子序列再次排序。 有人问，这样什么时候结束呢？ 递归到最底部的时候，子序列一定会被分成长度为0或1的序列，显然也就是排序好了。并且它一定会结束，因为每次迭代至少有一个元素到达了它最终的位置（就是可爱的哨兵啊）。 以上内容参考快速排序-维基百科 放一张图，更方便大家理解(图片转自http://www.cnblogs.com/CBDoctor/p/4077574.html) 实现方式 然后接下来拿出我丑的可怕的代码，来学习一下快排的具体实现方式（其实有很多种实现方法，在此只举一个例子） 123456789101112131415161718192021222324void quickSort(int left, int right)//left，right代表的是待排序的区间&#123; int i = left, j = right; int mid = arr[(i+j)/2];//这就是pivot，建议随机一个以免被卡（其实并不会怎样） while(i &lt;= j) //这个while循环实现的是从哨兵左边找一个比哨兵大的数，从哨兵右边找一个比它小的数，若i，j未相遇则交换这两个值，直到i，j相遇 &#123; while(arr[i] &lt; mid) i ++; while(arr[j] &gt; mid) j --; if(i &lt;= j)&#123; int tmp; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; i ++; j --; &#125; &#125; if(i &lt; right)//只要哨兵右边还有数，就递归继续进行排序 quickSort(i, right); if(left &lt; j)//只要哨兵左边还有数，就递归继续进行排序 quickSort(left, j);&#125; 快速排序的优缺点优点： 非常快速（在O（N*logN）的排序中常数小），为原址排序（不需要像归并一样的额外辅助空间）缺点：不稳定]]></content>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
</search>
